<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Face Tracking - M≈© & R√¢u 3D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
                 #video {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             object-fit: cover;
         }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #debug {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .controls h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .control-group input {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
        <canvas id="debug"></canvas>
        
        <div class="controls">
            <h3>üé≠ AR Face Tracking</h3>
            
            <div class="control-group">
                <label>M≈© (Hat):</label>
                <input type="checkbox" id="showHat" checked>
                <label>V·ªã tr√≠ m≈© (0.55-0.75):</label>
                <input type="range" id="hatPosition" min="0.55" max="0.75" step="0.01" value="0.65">
                <span id="hatPosValue">0.65</span>
            </div>
            
            <div class="control-group">
                <label>R√¢u (Beard):</label>
                <input type="checkbox" id="showBeard" checked>
                <label>V·ªã tr√≠ r√¢u (0.1-0.2):</label>
                <input type="range" id="beardPosition" min="0.1" max="0.2" step="0.01" value="0.15">
                <span id="beardPosValue">0.15</span>
            </div>
            
                         <div class="control-group">
                 <label>ƒê·ªô m∆∞·ª£t (Responsiveness):</label>
                 <input type="range" id="smoothing" min="0.1" max="0.9" step="0.1" value="0.7">
                 <span id="smoothingValue">0.7</span>
             </div>
            
                         <div class="control-group">
                 <label>Che khu·∫•t (Occlusion):</label>
                 <input type="checkbox" id="occlusion" checked>
             </div>
             
             <div class="control-group">
                 <label>Hi·ªÉn th·ªã landmarks:</label>
                 <input type="checkbox" id="showLandmarks" checked>
             </div>
             
             <div class="control-group">
                 <button id="reloadModels" style="width: 100%; padding: 8px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">
                     üîÑ Load l·∫°i Models
                 </button>
             </div>
             
             <div class="control-group">
                 <button id="testPosition" style="width: 100%; padding: 8px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;">
                     üéØ Test V·ªã tr√≠ Model
                 </button>
             </div>
             
             <div class="control-group">
                 <button id="debugModel" style="width: 100%; padding: 8px; background: #FF9800; color: white; border: none; border-radius: 5px; cursor: pointer;">
                     üîç Debug Model Info
                 </button>
             </div>
        </div>
        
        <div class="status" id="status">ƒêang kh·ªüi t·∫°o...</div>
        <div class="loading" id="loading">ƒêang t·∫£i MediaPipe...</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675466862/drawing_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Kh·ªüi t·∫°o bi·∫øn to√†n c·ª•c
        let faceMesh;
        let camera;
        let canvas;
        let ctx;
        let scene, renderer, camera3D;
                 let hatModel, beardModel;
         let faceMesh3D;
         let prevHeadPose = null;
         let prevHeadScale = 1;
         let modelLoaded = false; // Theo d√µi tr·∫°ng th√°i load model
        
        // C√°c ƒëi·ªÉm landmark quan tr·ªçng
        const LANDMARKS = {
            LEFT_EAR: 234,
            RIGHT_EAR: 454,
            FOREHEAD: 10,
            CHIN: 152,
            NOSE_BRIDGE: 168
        };
        
                 // C·∫•u h√¨nh
         const config = {
             hatPosition: 2,
             beardPosition: 0.15,
             smoothing: 0.7,
             occlusion: true,
             showHat: true,
             showBeard: true,
             showLandmarks: true,
             // Scale calibration
             refEarDistanceOfHat: 0.15, // Kho·∫£ng c√°ch tai-tai tham chi·∫øu cho m≈© (m√©t)
             refEarDistanceOfBeard: 0.15, // Kho·∫£ng c√°ch tai-tai tham chi·∫øu cho r√¢u (m√©t)
             hatScaleMul: 1.0,
             beardScaleMul: 1.0
         };

        // Kh·ªüi t·∫°o MediaPipe Face Mesh
        async function initFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`;
                }
            });

                         faceMesh.setOptions({
                 maxNumFaces: 1,
                 refineLandmarks: true,
                 minDetectionConfidence: 0.5,
                 minTrackingConfidence: 0.5,
                 selfieMode: false
             });

            faceMesh.onResults(onResults);
            
            // Kh·ªüi t·∫°o camera
            camera = new Camera(document.getElementById('video'), {
                onFrame: async () => {
                    await faceMesh.send({image: document.getElementById('video')});
                },
                width: 1280,
                height: 720
            });
            
            await camera.start();
            document.getElementById('loading').style.display = 'none';
        }

                 // X·ª≠ l√Ω k·∫øt qu·∫£ t·ª´ MediaPipe
         function onResults(results) {
             if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                 const landmarks = results.multiFaceLandmarks[0];
                 const worldLandmarks = results.multiFaceWorldLandmarks?.[0] ?? null;

                 // ∆Ø·ªõc l∆∞·ª£ng pose ƒë·∫ßu (c√≥ th·ªÉ s·ª≠ d·ª•ng screen landmarks n·∫øu world landmarks kh√¥ng c√≥)
                 const headPose = estimateHeadPose(landmarks, worldLandmarks);
                
                                 // C·∫≠p nh·∫≠t 3D models
                 if (headPose) {
                     update3DModels(headPose);
                     const coordType = headPose.useWorldCoords ? 'World' : 'Screen';
                     document.getElementById('status').textContent = `ƒê√£ ph√°t hi·ªán khu√¥n m·∫∑t (${coordType} coords)`;
                 } else {
                     document.getElementById('status').textContent = 'ƒêang x·ª≠ l√Ω landmarks...';
                 }
                 
                 // V·∫Ω landmarks (t√πy ch·ªçn)
                 if (config.showLandmarks) {
                     drawLandmarks(results.multiFaceLandmarks);
                 }
            } else {
                document.getElementById('status').textContent = 'Kh√¥ng t√¨m th·∫•y khu√¥n m·∫∑t';
            }
        }

                 // ∆Ø·ªõc l∆∞·ª£ng pose ƒë·∫ßu t·ª´ landmarks
        function toScene(p){
            const aspect = window.innerWidth / window.innerHeight;
            return { x: (p.x - 0.5) * 2 * aspect, y: (0.5 - p.y) * 2, z: 0 };
        }

        function estimateHeadPose(landmarks, worldLandmarks) {
            // Screen ‚Üí scene
            const LE = toScene(landmarks[LANDMARKS.LEFT_EAR]);
            const RE = toScene(landmarks[LANDMARKS.RIGHT_EAR]);
            const FH = toScene(landmarks[LANDMARKS.FOREHEAD]);
            const CH = toScene(landmarks[LANDMARKS.CHIN]);

            // H∆∞·ªõng ƒë·∫ßu (l·∫•y t·ª´ world ƒë·ªÉ quay model cho chu·∫©n)
            const xW = normalize(subtract(worldLandmarks[LANDMARKS.RIGHT_EAR],
                                            worldLandmarks[LANDMARKS.LEFT_EAR]));
            const yW = normalize(subtract(worldLandmarks[LANDMARKS.CHIN],
                                            worldLandmarks[LANDMARKS.FOREHEAD]));
            const zW = normalize(cross(xW, yW));
            const yAxisW = cross(zW, xW);

            // H∆∞·ªõng "l√™n" theo **m·∫∑t ph·∫≥ng ·∫£nh** ƒë·ªÉ ƒë·∫∑t anchor (kh√¥ng tr·ªôn h·ªá)
            const y2D = normalize(subtract(CH, FH));

            const headCenter = midpoint(LE, RE);
            const headSize   = distance(LE, RE);

            // Anchor trong c√πng 1 h·ªá to·∫° ƒë·ªô
            const headCenterOffset = add(headCenter, multiply(y2D, 0.10 * headSize));
            const hatAnchor   = add(headCenterOffset, multiply(y2D,  config.hatPosition  * headSize));
            const beardAnchor = add(CH,               multiply(y2D, -config.beardPosition * headSize));

            // Quaternion t·ª´ world axes ƒë·ªÉ xoay m≈©/r√¢u
            const m = new THREE.Matrix4().makeBasis(
                new THREE.Vector3(xW.x, xW.y, xW.z),
                new THREE.Vector3(yAxisW.x, yAxisW.y, yAxisW.z),
                new THREE.Vector3(zW.x, zW.y, zW.z)
            );
            const q = new THREE.Quaternion().setFromRotationMatrix(m);

            // T√πy b·∫°n gi·ªØ thang ƒëo theo world (·ªïn ƒë·ªãnh nh·∫•t)
            const earToEarWorld = distance(worldLandmarks[LANDMARKS.LEFT_EAR],
                                            worldLandmarks[LANDMARKS.RIGHT_EAR]);

            return { headCenter: headCenterOffset, hatAnchor, beardAnchor,
                    rotation: q, scale: headSize, earToEarWorld,
                    landmarks: { leftEar: LE, rightEar: RE, forehead: FH, chin: CH } };
            }

                 // Kh·ªüi t·∫°o Three.js scene
        function initThreeJS() {
             scene = new THREE.Scene();
             scene.background = null;
             
             // Camera 3D - Orthographic ƒë·ªÉ kh·ªõp v·ªõi kh√¥ng gian m√†n h√¨nh 0..1
             const aspect = window.innerWidth / window.innerHeight;
             camera3D = new THREE.OrthographicCamera(-aspect, aspect, 1, -1, 0.1, 1000);
             camera3D.position.z = 1;
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                alpha: true,
                antialias: true 
            });
            renderer.setClearColor(0x000000, 0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // √Ånh s√°ng
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 1, 1);
            scene.add(directionalLight);
            
            // T·∫°o mesh khu√¥n m·∫∑t cho occlusion
            if (config.occlusion) {
                createFaceOcclusionMesh();
            }
            
            // T·∫°o m√¥ h√¨nh m≈© v√† r√¢u ƒë∆°n gi·∫£n
            createSimpleModels();
            
            animate();
        }

        // T·∫°o mesh occlusion cho khu√¥n m·∫∑t
        function createFaceOcclusionMesh() {
            // D·ªçn c√°i c≈© (n·∫øu c√≥)
            if (faceMesh3D) {
                scene.remove(faceMesh3D);
                faceMesh3D.geometry?.dispose();
                faceMesh3D.material?.dispose();
                faceMesh3D = null;
            }

            // Geometry t·∫°m (sau n√†y thay b·∫±ng face mesh 468 ƒëi·ªÉm)
            const faceGeometry = new THREE.SphereGeometry(1, 32, 32);

            // Material depth-only: che khu·∫•t nh∆∞ng KH√îNG t√¥ m√†u
            const faceMaterial = new THREE.MeshBasicMaterial({
                colorWrite: false,
                depthWrite: true,
                depthTest: true
            });

            faceMesh3D = new THREE.Mesh(faceGeometry, faceMaterial);
            faceMesh3D.renderOrder = 0;
            scene.add(faceMesh3D);
        }


                 // T·∫°o m√¥ h√¨nh m≈© v√† r√¢u ƒë∆°n gi·∫£n
        function createSimpleModels() {
            // M≈©
            const hatGeometry = new THREE.ConeGeometry(0.5, 0.3, 8);
            const hatMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            hatModel = new THREE.Mesh(hatGeometry, hatMaterial);
            hatModel.visible = config.showHat;
            hatModel.renderOrder = 1;     // <-- g√°n sau khi ƒë√£ c√≥ hatModel
            scene.add(hatModel);

            // R√¢u
            const beardGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.1);
            const beardMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            beardModel = new THREE.Mesh(beardGeometry, beardMaterial);
            beardModel.visible = config.showBeard;
            beardModel.renderOrder = 1;   // <-- g√°n sau khi ƒë√£ c√≥ beardModel
            scene.add(beardModel);

            // Load GLTF models th·ª±c t·∫ø
            loadGLTFModels();
        }

         
         // Load GLTF models th·ª±c t·∫ø
         function loadGLTFModels() {
             const loader = new THREE.GLTFLoader();
             
             console.log('B·∫Øt ƒë·∫ßu load GLTF models...');
             
             // Load m≈© t·ª´ file GLB
             loader.load('assets/low_poly_hat/hat.gltf', (gltf) => {
                 console.log('ƒê√£ load th√†nh c√¥ng m√¥ h√¨nh m≈© GLTF:', gltf);
                 
                 const hatGLTF = gltf.scene;
                 hatGLTF.scale.setScalar(0.1); // Scale m·∫∑c ƒë·ªãnh
                 hatGLTF.visible = config.showHat;
                 
                 // D·ªçn d·∫πp model c≈©
                 if (hatModel) {
                     scene.remove(hatModel);
                     if (hatModel.geometry) hatModel.geometry.dispose();
                     if (hatModel.material) hatModel.material.dispose();
                 }
                 
                 hatModel = hatGLTF;
                 hatModel.renderOrder = 1;
                 scene.add(hatModel);
                 
                 // ƒê·∫∑t v·ªã tr√≠ test ban ƒë·∫ßu
                 hatModel.position.set(0, 0, 0);
                 
                                   console.log('ƒê√£ thay th·∫ø m√¥ h√¨nh m≈© b·∫±ng GLTF');
                  console.log('Hat model position:', hatModel.position);
                  console.log('Hat model scale:', hatModel.scale);
                  
                  // Set flag v√† c·∫≠p nh·∫≠t status
                  modelLoaded = true;
                  document.getElementById('status').textContent = 'ƒê√£ load m√¥ h√¨nh m≈© GLTF th√†nh c√¥ng!';
                 
             }, (progress) => {
                 console.log('ƒêang load m√¥ h√¨nh m≈©:', (progress.loaded / progress.total * 100).toFixed(1) + '%');
             }, (error) => {
                 console.error('L·ªói load m√¥ h√¨nh m≈© GLTF:', error);
                 console.log('S·ª≠ d·ª•ng m√¥ h√¨nh m≈© ƒë∆°n gi·∫£n');
             });
             
             // TODO: Load r√¢u khi c√≥ file beard.glb
             // loader.load('model/beard.glb', (gltf) => {
             //     // T∆∞∆°ng t·ª± nh∆∞ m≈©
             // });
         }

                 // C·∫≠p nh·∫≠t v·ªã tr√≠ v√† rotation c·ªßa m√¥ h√¨nh 3D
         function update3DModels(headPose) {
             if (!headPose) return;
             
             // Smoothing - s·ª≠ d·ª•ng t = 1 - smoothing ƒë·ªÉ ƒë·∫£o ng∆∞·ª£c logic
             const t = 1 - config.smoothing;
             
             if (prevHeadPose) {
                 headPose.headCenter = lerp(prevHeadPose.headCenter, headPose.headCenter, t);
                 headPose.hatAnchor = lerp(prevHeadPose.hatAnchor, headPose.hatAnchor, t);
                 headPose.beardAnchor = lerp(prevHeadPose.beardAnchor, headPose.beardAnchor, t);
                 headPose.rotation = slerp(prevHeadPose.rotation, headPose.rotation, t);
                 headPose.scale = lerp(prevHeadPose.scale, headPose.scale, t);
                 headPose.earToEarWorld = lerp(prevHeadPose.earToEarWorld, headPose.earToEarWorld, t);
             }
             
             // T√≠nh scale ch√≠nh x√°c d·ª±a tr√™n ear-to-ear distance
             const hatScale = (headPose.earToEarWorld / config.refEarDistanceOfHat) * config.hatScaleMul;
             const beardScale = (headPose.earToEarWorld / config.refEarDistanceOfBeard) * config.beardScaleMul;
             
                           // C·∫≠p nh·∫≠t m≈©
              if (hatModel && config.showHat && modelLoaded) {
                  hatModel.position.set(headPose.hatAnchor.x, headPose.hatAnchor.y, headPose.hatAnchor.z);
                  hatModel.quaternion.copy(headPose.rotation);
                  
                  // ƒê·∫£m b·∫£o scale kh√¥ng qu√° nh·ªè
                  const finalScale = Math.max(hatScale, 0.01);
                  hatModel.scale.setScalar(finalScale);
                  
                  // Debug: ch·ªâ log khi c·∫ßn thi·∫øt
                  if (Math.random() < 0.01) { // Ch·ªâ log 1% th·ªùi gian
                      console.log('Hat position:', headPose.hatAnchor.x, headPose.hatAnchor.y, headPose.hatAnchor.z);
                      console.log('Hat scale:', finalScale);
                  }
              }
             
             // C·∫≠p nh·∫≠t r√¢u
             if (beardModel && config.showBeard) {
                 beardModel.position.set(headPose.beardAnchor.x, headPose.beardAnchor.y, headPose.beardAnchor.z);
                 beardModel.quaternion.copy(headPose.rotation);
                 beardModel.scale.setScalar(beardScale);
             }
             
             // C·∫≠p nh·∫≠t face occlusion mesh
             if (faceMesh3D && config.occlusion) {
                 faceMesh3D.position.copy(headPose.headCenter);
                 faceMesh3D.quaternion.copy(headPose.rotation);
                 faceMesh3D.scale.setScalar(headPose.scale * 0.8);
             }
             
             prevHeadPose = headPose;
         }

                 // V·∫Ω landmarks tr√™n canvas debug ri√™ng bi·ªát
         function drawLandmarks(landmarks) {
             if (!landmarks || landmarks.length === 0) return;
             
             const debugCanvas = document.getElementById('debug');
             const ctx = debugCanvas.getContext('2d');
             
             // ƒê·∫£m b·∫£o canvas c√≥ k√≠ch th∆∞·ªõc ƒë√∫ng v·ªõi DPR
             const dpr = window.devicePixelRatio || 1;
             const rect = debugCanvas.getBoundingClientRect();
             
             if (debugCanvas.width !== rect.width * dpr || debugCanvas.height !== rect.height * dpr) {
                 debugCanvas.width = rect.width * dpr;
                 debugCanvas.height = rect.height * dpr;
                 ctx.scale(dpr, dpr);
             }
             
             ctx.clearRect(0, 0, rect.width, rect.height);
             
             // V·∫Ω c√°c ƒëi·ªÉm quan tr·ªçng
             const importantPoints = [
                 LANDMARKS.LEFT_EAR, LANDMARKS.RIGHT_EAR,
                 LANDMARKS.FOREHEAD, LANDMARKS.CHIN, LANDMARKS.NOSE_BRIDGE
             ];
             
             ctx.strokeStyle = '#00ff00';
             ctx.lineWidth = 2;
             ctx.fillStyle = '#ff0000';
             
             importantPoints.forEach(pointIndex => {
                 const point = landmarks[0][pointIndex];
                 if (point) {
                     ctx.beginPath();
                     ctx.arc(point.x * rect.width, point.y * rect.height, 5, 0, 2 * Math.PI);
                     ctx.fill();
                 }
             });
         }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera3D);
        }

        // Utility functions
        function normalize(v) {
            const length = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
            return { x: v.x / length, y: v.y / length, z: v.z / length };
        }

        function subtract(a, b) {
            return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
        }

        function add(a, b) {
            return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };
        }

        function multiply(v, scalar) {
            return { x: v.x * scalar, y: v.y * scalar, z: v.z * scalar };
        }

        function cross(a, b) {
            return {
                x: a.y * b.z - a.z * b.y,
                y: a.z * b.x - a.x * b.z,
                z: a.x * b.y - a.y * b.x
            };
        }

        function midpoint(a, b) {
            return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2, z: (a.z + b.z) / 2 };
        }

        function distance(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const dz = a.z - b.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        function lerp(a, b, t) {
            return { x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t, z: a.z + (b.z - a.z) * t };
        }

        function slerp(a, b, t) {
            const quat = new THREE.Quaternion();
            quat.slerpQuaternions(a, b, t);
            return quat;
        }

        

        // Event listeners
        document.getElementById('hatPosition').addEventListener('input', (e) => {
            config.hatPosition = parseFloat(e.target.value);
            document.getElementById('hatPosValue').textContent = e.target.value;
        });

        document.getElementById('beardPosition').addEventListener('input', (e) => {
            config.beardPosition = parseFloat(e.target.value);
            document.getElementById('beardPosValue').textContent = e.target.value;
        });

        document.getElementById('smoothing').addEventListener('input', (e) => {
            config.smoothing = parseFloat(e.target.value);
            document.getElementById('smoothingValue').textContent = e.target.value;
        });

        document.getElementById('showHat').addEventListener('change', (e) => {
            config.showHat = e.target.checked;
            if (hatModel) hatModel.visible = config.showHat;
        });

        document.getElementById('showBeard').addEventListener('change', (e) => {
            config.showBeard = e.target.checked;
            if (beardModel) beardModel.visible = config.showBeard;
        });

                 document.getElementById('occlusion').addEventListener('change', (e) => {
             config.occlusion = e.target.checked;
             if (faceMesh3D) faceMesh3D.visible = config.occlusion;
         });
         
         document.getElementById('showLandmarks').addEventListener('change', (e) => {
             config.showLandmarks = e.target.checked;
             if (!config.showLandmarks) {
                 const debugCanvas = document.getElementById('debug');
                 const ctx = debugCanvas.getContext('2d');
                 const rect = debugCanvas.getBoundingClientRect();
                 ctx.clearRect(0, 0, rect.width, rect.height);
             }
         });
         
         document.getElementById('reloadModels').addEventListener('click', () => {
             console.log('Reloading models...');
             document.getElementById('status').textContent = 'ƒêang load l·∫°i models...';
             loadGLTFModels();
         });
         
         document.getElementById('testPosition').addEventListener('click', () => {
             console.log('Testing model position...');
             if (hatModel) {
                 console.log('Hat model position:', hatModel.position);
                 console.log('Hat model scale:', hatModel.scale);
                 console.log('Hat model visible:', hatModel.visible);
                 
                 // Test ƒë·∫∑t model ·ªü gi·ªØa m√†n h√¨nh
                 hatModel.position.set(0, 0, 0);
                 hatModel.scale.setScalar(0.1);
                 console.log('ƒê√£ ƒë·∫∑t model ·ªü gi·ªØa m√†n h√¨nh (0,0,0)');
             }
         });
         
         document.getElementById('debugModel').addEventListener('click', () => {
             console.log('=== DEBUG MODEL INFO ===');
             console.log('Model loaded:', modelLoaded);
             if (hatModel) {
                 console.log('Hat model exists:', true);
                 console.log('Hat model position:', hatModel.position);
                 console.log('Hat model scale:', hatModel.scale);
                 console.log('Hat model visible:', hatModel.visible);
                 console.log('Hat model in scene:', scene.children.includes(hatModel));
                 console.log('Hat model renderOrder:', hatModel.renderOrder);
                 
                 // Ki·ªÉm tra camera
                 console.log('Camera position:', camera3D.position);
                 console.log('Camera near/far:', camera3D.near, camera3D.far);
                 console.log('Camera left/right:', camera3D.left, camera3D.right);
                 console.log('Camera top/bottom:', camera3D.top, camera3D.bottom);
             } else {
                 console.log('Hat model exists:', false);
             }
             console.log('========================');
         });

                 // Resize handler
         window.addEventListener('resize', () => {
             const aspect = window.innerWidth / window.innerHeight;
             camera3D.left = -aspect;
             camera3D.right = aspect;
             camera3D.top = 1;
             camera3D.bottom = -1;
             camera3D.updateProjectionMatrix();
             renderer.setSize(window.innerWidth, window.innerHeight);
             
             // C·∫≠p nh·∫≠t debug canvas v·ªõi DPR
             const debugCanvas = document.getElementById('debug');
             const dpr = window.devicePixelRatio || 1;
             const rect = debugCanvas.getBoundingClientRect();
             debugCanvas.width = rect.width * dpr;
             debugCanvas.height = rect.height * dpr;
         });

        // Kh·ªüi t·∫°o ·ª©ng d·ª•ng
        async function init() {
            try {
                await initFaceMesh();
                initThreeJS();
                document.getElementById('status').textContent = 'S·∫µn s√†ng! Di chuy·ªÉn khu√¥n m·∫∑t ƒë·ªÉ th·∫•y hi·ªáu ·ª©ng';
            } catch (error) {
                console.error('L·ªói kh·ªüi t·∫°o:', error);
                document.getElementById('status').textContent = 'L·ªói: ' + error.message;
            }
        }

        // B·∫Øt ƒë·∫ßu ·ª©ng d·ª•ng
        init();
    </script>
</body>
</html>
