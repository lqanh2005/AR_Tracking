<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hat Tracking - Production</title>
  <!-- MediaPipe Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
  <!-- Three.js and GLTFLoader Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: Arial, sans-serif;
    }
    #output_canvas { position: absolute; top: 0; left: 0; }
    #three_canvas { position: absolute; top: 0; left: 0; }
    #settings-toggle {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      color: white;
      border: none;
      padding: 10px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 16px;
      z-index: 1000;
    }
    #settings-panel {
      position: absolute;
      top: 60px;
      right: 10px;
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 1000;
      display: none;
      min-width: 200px;
    }
    #settings-panel label {
      display: block;
      margin: 8px 0;
    }
    #settings-panel button {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .save-btn { background: #4CAF50; color: white; }
    .reset-btn { background: #f44336; color: white; }
  </style>
</head>
<body>
  <div class="container">
    <video class="input_video" style="display: none;"></video>
    <canvas class="output_canvas" width="1280px" height="720px"></canvas>
    <canvas id="three_canvas" width="1280px" height="720px"></canvas>
  </div>
  
  <button id="settings-toggle">‚öôÔ∏è</button>
  
  <div id="settings-panel">
    <h4>üé© ƒêi·ªÅu ch·ªânh M≈©</h4>
    <label>
      Scale: <input type="range" id="scale" min="0.01" max="0.5" step="0.01" value="0.15">
      <span id="scale-value">0.15</span>
    </label>
    <label>
      Y Offset: <input type="range" id="y-offset" min="0.1" max="2.0" step="0.1" value="0.6">
      <span id="y-offset-value">0.6</span>
    </label>
    <label>
      Z Offset: <input type="range" id="z-offset" min="-2.0" max="2.0" step="0.1" value="0.0">
      <span id="z-offset-value">0.0</span>
    </label>
    <label>
      <input type="checkbox" id="show-mesh" checked> Hi·ªÉn th·ªã Face Mesh
    </label>
    <hr style="margin: 10px 0; border-color: #555;">
    <button id="save-settings" class="save-btn">üíæ L∆∞u Settings</button>
    <button id="reset-settings" class="reset-btn">üîÑ Reset</button>
  </div>

  <script type="module">
    // MediaPipe Setup
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');

    // Three.js Setup
    const threeCanvas = document.getElementById('three_canvas');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1280 / 720, 0.1, 1000);
    camera.position.z = 5;
    const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true });
    renderer.setSize(1280, 720);

    // Add ambient light
    const light = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(light);

    // Add directional light for better visibility
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(0, 1, 1);
    scene.add(dirLight);

    // Variables
    let hatModel;
    let currentRotation = { x: 0, y: 0, z: 0 };
    let targetRotation = { x: 0, y: 0, z: 0 };
    let scaleValue = 0.15;
    let yOffset = 0.6;
    let zOffset = 0.0;
    let showMesh = true;

    // Load saved settings from localStorage
    function loadSettings() {
      const savedSettings = localStorage.getItem('hatTrackingSettings');
      if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        scaleValue = settings.scaleValue || 0.15;
        yOffset = settings.yOffset || 0.6;
        zOffset = settings.zOffset || 0.0;
        showMesh = settings.showMesh !== undefined ? settings.showMesh : true;
        
        // Update UI controls
        document.getElementById('scale').value = scaleValue;
        document.getElementById('scale-value').textContent = scaleValue.toFixed(2);
        document.getElementById('y-offset').value = yOffset;
        document.getElementById('y-offset-value').textContent = yOffset.toFixed(1);
        document.getElementById('z-offset').value = zOffset;
        document.getElementById('z-offset-value').textContent = zOffset.toFixed(1);
        document.getElementById('show-mesh').checked = showMesh;
      }
    }

    // Save settings to localStorage
    function saveSettings() {
      const settings = {
        scaleValue: scaleValue,
        yOffset: yOffset,
        zOffset: zOffset,
        showMesh: showMesh,
        timestamp: new Date().toISOString()
      };
      localStorage.setItem('hatTrackingSettings', JSON.stringify(settings));
    }

    // Reset settings to default
    function resetSettings() {
      scaleValue = 0.15;
      yOffset = 0.6;
      zOffset = 0.0;
      showMesh = true;
      
      // Update UI controls
      document.getElementById('scale').value = scaleValue;
      document.getElementById('scale-value').textContent = scaleValue.toFixed(2);
      document.getElementById('y-offset').value = yOffset;
      document.getElementById('y-offset-value').textContent = yOffset.toFixed(1);
      document.getElementById('z-offset').value = zOffset;
      document.getElementById('z-offset-value').textContent = zOffset.toFixed(1);
      document.getElementById('show-mesh').checked = showMesh;
      
      // Remove saved settings
      localStorage.removeItem('hatTrackingSettings');
    }

    // Load the hat model
    const loader = new THREE.GLTFLoader();
    loader.load(
      'assets/low_poly_hat/hat.gltf',
      (gltf) => {
        hatModel = gltf.scene;
        hatModel.scale.set(scaleValue, scaleValue, scaleValue);
        scene.add(hatModel);
      },
      (xhr) => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
      (error) => {
        console.error('Error loading hat model:', error);
        // Create a simple hat placeholder if model fails to load
        const geometry = new THREE.ConeGeometry(0.5, 1, 8);
        const material = new THREE.MeshLambertMaterial({ color: 0x808080 });
        hatModel = new THREE.Mesh(geometry, material);
        hatModel.rotation.x = Math.PI / 2;
        scene.add(hatModel);
      }
    );

    // Function to calculate head rotation
    function calculateHeadRotation(landmarks) {
      const nose = landmarks[1];
      const leftEye = landmarks[33];
      const rightEye = landmarks[263];
      const leftEar = landmarks[234];
      const rightEar = landmarks[454];

      // Y rotation (left-right)
      const eyeCenterX = (leftEye.x + rightEye.x) / 2;
      const earCenterX = (leftEar.x + rightEar.x) / 2;
      const headWidth = Math.abs(leftEar.x - rightEar.x);
      const yRotation = Math.atan2(eyeCenterX - earCenterX, headWidth * 0.3) * 0.5;

      // X rotation (up-down)
      const eyeCenterY = (leftEye.y + rightEye.y) / 2;
      const noseY = nose.y;
      const headHeight = Math.abs(leftEye.y - nose.y) * 2;
      const xRotation = Math.atan2(noseY - eyeCenterY, headHeight * 0.5) * 0.8;

      // Z rotation (tilt)
      const leftEyeY = leftEye.y;
      const rightEyeY = rightEye.y;
      const eyeDistance = Math.abs(leftEye.x - rightEye.x);
      const zRotation = Math.atan2(rightEyeY - leftEyeY, eyeDistance) * 0.3;

      return { x: xRotation, y: yRotation, z: zRotation };
    }

    // Function to smooth rotation
    function smoothRotation(target, current, factor = 0.1) {
      return {
        x: current.x + (target.x - current.x) * factor,
        y: current.y + (target.y - current.y) * factor,
        z: current.z + (target.z - current.z) * factor
      };
    }

    // MediaPipe FaceMesh Configuration
    const faceMesh = new FaceMesh({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
      }
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    // Process FaceMesh results
    faceMesh.onResults((results) => {
      // Clear and draw video
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];

        // Draw face mesh if enabled
        if (showMesh) {
          drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, { 
            color: '#C0C0C020', 
            lineWidth: 0.5 
          });
        }

        // Get forehead position
        const forehead = landmarks[10];
        const x = forehead.x * 1280;
        const y = forehead.y * 720;
        const z = forehead.z * 1000;

        // Map to Three.js coordinates
        const threeX = (x - 640) / 1280 * 3;
        const threeY = -(y - 360) / 720 * 3;
        const threeZ = -z / 200 + zOffset;

        // Calculate and apply rotation
        const headRotation = calculateHeadRotation(landmarks);
        targetRotation = headRotation;
        currentRotation = smoothRotation(targetRotation, currentRotation);

        // Update hat model
        if (hatModel) {
          hatModel.position.set(threeX, threeY + yOffset, threeZ);
          hatModel.rotation.x = currentRotation.x;
          hatModel.rotation.y = currentRotation.y;
          hatModel.rotation.z = currentRotation.z;
          hatModel.scale.set(scaleValue, scaleValue, scaleValue);
        }
      }
      canvasCtx.restore();

      // Render Three.js scene
      renderer.render(scene, camera);
    });

    // Load settings on startup
    loadSettings();

    // Start camera
    const cameraFeed = new Camera(videoElement, {
      onFrame: async () => {
        await faceMesh.send({ image: videoElement });
      },
      width: 1280,
      height: 720
    });
    cameraFeed.start();

    // Settings panel toggle
    document.getElementById('settings-toggle').addEventListener('click', () => {
      const panel = document.getElementById('settings-panel');
      panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    });

    // Settings management buttons
    document.getElementById('save-settings').addEventListener('click', () => {
      saveSettings();
      alert('‚úÖ Settings ƒë√£ ƒë∆∞·ª£c l∆∞u!');
    });

    document.getElementById('reset-settings').addEventListener('click', () => {
      if (confirm('‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc mu·ªën reset v·ªÅ settings m·∫∑c ƒë·ªãnh?')) {
        resetSettings();
        alert('üîÑ Settings ƒë√£ ƒë∆∞·ª£c reset!');
      }
    });

    // Auto-save settings when values change (with debounce)
    let saveTimeout;
    function autoSaveSettings() {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        saveSettings();
      }, 1000); // Save after 1 second of no changes
    }

    // Add auto-save to all controls
    document.getElementById('scale').addEventListener('input', (e) => {
      scaleValue = parseFloat(e.target.value);
      document.getElementById('scale-value').textContent = scaleValue.toFixed(2);
      autoSaveSettings();
    });

    document.getElementById('y-offset').addEventListener('input', (e) => {
      yOffset = parseFloat(e.target.value);
      document.getElementById('y-offset-value').textContent = yOffset.toFixed(1);
      autoSaveSettings();
    });

    document.getElementById('z-offset').addEventListener('input', (e) => {
      zOffset = parseFloat(e.target.value);
      document.getElementById('z-offset-value').textContent = zOffset.toFixed(1);
      autoSaveSettings();
    });

    document.getElementById('show-mesh').addEventListener('change', (e) => {
      showMesh = e.target.checked;
      autoSaveSettings();
    });
  </script>
</body>
</html> 