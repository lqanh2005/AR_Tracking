<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>MediaPipe FaceMesh with 3D Hat Model</title>
  <!-- MediaPipe Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
  <!-- Three.js and GLTFLoader Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: Arial, sans-serif;
    }
    #output_canvas { position: absolute; top: 0; left: 0; }
    #three_canvas { position: absolute; top: 0; left: 0; }
    #settings-toggle {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      color: white;
      border: none;
      padding: 10px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 16px;
      z-index: 1000;
    }
    #settings-panel {
      position: absolute;
      top: 60px;
      right: 10px;
      background: rgba(0,0,0,0.9);
      color:white;
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 1000;
      display: none;
      min-width: 200px;
    }
    #settings-panel label {
      display: block;
      margin: 8px 0;
    }
    #settings-panel button {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .save-btn { background: #4CAF50; color: white; }
    .reset-btn { background: #f44336; color: white; }
  </style>
</head>
<body>
  <div class="container">
    <video class="input_video" style="display: none;"></video>
    <canvas class="output_canvas" width="1280" height="720"
        style="position: absolute; top: 0; left: 0; z-index: 1;"></canvas>

    <canvas id="three_canvas" width="1280" height="720"
        style="position: absolute; top: 0; left: 0; z-index: 2; pointer-events: none;"></canvas>

  </div>
  
  <button id="settings-toggle">‚öôÔ∏è</button>
  
  <div id="settings-panel">
    <h4>üé© ƒêi·ªÅu ch·ªânh M≈©</h4>



    <label>
             Smoothing Factor: <input type="range" id="smoothing" min="0.01" max="0.5" step="0.01" value="0.4">
       <span id="smoothing-value">0.4</span>
    </label>


    <h4>üëì ƒêi·ªÅu ch·ªânh K√≠nh</h4>

    <label>
      Glasses Y Offset: <input type="range" id="glasses-y-offset" min="-0.2" max="0.2" step="0.01" value="0.05">
      <span id="glasses-y-offset-value">0.05</span>
    </label>

                                     <label>
      Hat Y Offset (from Forehead): <input type="range" id="hat-y-offset" min="-0.3" max="0.1" step="0.01" value="-0.1">
      <span id="hat-y-offset-value">-0.1</span>
    </label>

                                     <label>
         <input type="checkbox" id="show-mesh" checked> Hi·ªÉn th·ªã Face Mesh
       </label>
       <label>
         <input type="checkbox" id="show-mesh-tesselation" checked> Tesselation (Xanh nh·∫°t)
       </label>
       <label>
         <input type="checkbox" id="show-mesh-contours" checked> Contours (Xanh d∆∞∆°ng)
       </label>
       <label>
         <input type="checkbox" id="show-mesh-irises" checked> Irises (Cyan)
       </label>
                   <label>
        <input type="checkbox" id="show-axes" checked> Hi·ªÉn th·ªã Tr·ª•c T·ªça ƒê·ªô (Oxyz)
      </label>

      <h4>üé≠ Depth Masking</h4>
      <label>
        <input type="checkbox" id="enable-depth-mask" checked> B·∫≠t Depth Masking (Stencil Buffer)
      </label>
      <label>
         <input type="checkbox" id="enable-head-replacement" unchecked> B·∫≠t Head Replacement (Thay th·∫ø ƒë·∫ßu b·∫±ng m≈©)
      </label>
      <label>
        <input type="checkbox" id="show-face-mask" unchecked> Hi·ªÉn th·ªã Face Mask (Debug)
      </label>
      <label>
        <input type="checkbox" id="show-head-occluder" unchecked> Hi·ªÉn th·ªã Head Occluder (Debug)
      </label>
      
      <div class="setting-group">
        <label for="head-occluder-size">Head Occluder Size:</label>
        <input type="range" id="head-occluder-size" min="0.8" max="2.0" step="0.1" value="1.2">
        <span id="head-occluder-size-value">1.2</span>
      </div>
      
      <div class="setting-group">
        <label for="head-proxy-scale-sensitivity">Head Proxy Scale Sensitivity:</label>
        <input type="range" id="head-proxy-scale-sensitivity" min="0.1" max="2.0" step="0.1" value="0.8">
        <span id="head-proxy-scale-sensitivity-value">0.8</span>
      </div>

      
      <div class="setting-group">
         <label for="edge-tracking">Edge Tracking Sensitivity:</label>
         <input type="range" id="edge-tracking" min="0.1" max="0.3" step="0.05" value="0.1">
         <span id="edge-tracking-value">0.1</span>
       </div>
                 <div id="debug-info" style="margin-top: 10px; font-size: 12px; color: #ccc;">
           <div>üéØ Face Mesh Components:</div>
           <div>‚Ä¢ Tesselation: L∆∞·ªõi ch√≠nh (Xanh nh·∫°t)</div>
           <div>‚Ä¢ Contours: Vi·ªÅn khu√¥n m·∫∑t (Xanh d∆∞∆°ng)</div>
           <div>‚Ä¢ Irises: M·ªëng m·∫Øt (Cyan)</div>
           <div>üéØ Landmarks ƒë∆∞·ª£c x√°c ƒë·ªãnh:</div>
           <div>‚Ä¢ M≈©i: ƒêi·ªÉm 1, 168 (Cyan)</div>
           <div>‚Ä¢ M·∫Øt: ƒêi·ªÉm 33, 263 (T√≠m)</div>
           <div>‚Ä¢ L√¥ng m√†y: ƒêi·ªÉm 70, 300 (V√†ng)</div>
           <div>‚Ä¢ Mi·ªáng: ƒêi·ªÉm 13, 14 (Cam)</div>
         </div>
    <hr style="margin: 10px 0; border-color: #555;">
    <button id="save-settings" class="save-btn">L∆∞u Settings</button>
    
    <div class="setting-group" style="margin-top: 10px;">
      <label for="model-scale-boost">Model Scale Boost:</label>
      <input type="range" id="model-scale-boost" min="0.5" max="10.0" step="0.5" value="1.0">
      <span id="model-scale-boost-value">1.0</span>
    </div>
    
    <div style="margin-top: 10px; font-size: 12px; color: #ccc;">
      <div id="scale-debug">Scale Debug Info:</div>
    </div>
  </div>
  <script type="module">
    // üîç DEBUG: Check if page loads
    console.log('üöÄ Script starting...');
    
    // Error handling
    window.addEventListener('error', (e) => {
      console.error('‚ùå Global Error:', e.error);
      alert('L·ªói JavaScript: ' + e.message);
    });
    
    // Wait for DOM to be ready
    document.addEventListener('DOMContentLoaded', function() {
      console.log('üìÑ DOM loaded, starting setup...');
      initApp();
    });
    
    function initApp() {
      // Loading indicator
      document.body.innerHTML += '<div id="loading" style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.8); color:white; padding:20px; border-radius:10px; z-index:9999;">üîÑ ƒêang t·∫£i...</div>';
      
      // üõ°Ô∏è SAFE EVENT LISTENER HELPER
      function safeAddEventListener(elementId, event, callback) {
        const element = document.getElementById(elementId);
        if (element) {
          element.addEventListener(event, callback);
          console.log(`‚úÖ Added listener for ${elementId}`);
          return true;
        } else {
          console.warn(`‚ö†Ô∏è Element ${elementId} not found`);
          return false;
        }
      }
      
//#region 
    // MediaPipe Setup
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    canvasElement.width = 1280;
    canvasElement.height = 720;
    const canvasCtx = canvasElement.getContext('2d');
    

    // Three.js Setup
    const threeCanvas = document.getElementById('three_canvas');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1280 / 720, 0.1, 1000);
    camera.position.z = 5;
    const renderer = new THREE.WebGLRenderer({ 
      canvas: threeCanvas, 
      alpha: true,
      stencil: true,  // B·∫≠t stencil buffer
      depth: true     // B·∫≠t depth buffer
    });
    renderer.setSize(1280, 720);
    
    // C·∫•u h√¨nh depth testing v√† stencil buffer
    renderer.sortObjects = false;  // T·∫Øt auto-sorting ƒë·ªÉ ki·ªÉm so√°t render order
    renderer.autoClear = false;    // T·∫Øt auto-clear ƒë·ªÉ c√≥ th·ªÉ clear selective

    // Add ambient light
    const light = new THREE.AmbientLight(0xffffff);
    scene.add(light);

    // Add directional light for better visibility
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(0, 1, 1);
    scene.add(directionalLight);

    // üé≠ STENCIL BUFFER & DEPTH MASK SETUP
    // T·∫°o material cho depth mask (ch·ªâ ghi depth, kh√¥ng ghi color)
    const depthMaskMaterial = new THREE.MeshBasicMaterial({
      colorWrite: false,      // Kh√¥ng ghi v√†o color buffer
      depthWrite: true,       // Ghi v√†o depth buffer  
      depthTest: true,        // Test depth
      transparent: false,
      visible: true
    });

    // Material cho objects c·∫ßn b·ªã che (s·∫Ω b·ªã depth test)
    const occludedMaterial = new THREE.MeshBasicMaterial({
      color: 0xff0000,
      transparent: true,
      opacity: 0.5,
      depthWrite: false,      // Kh√¥ng ghi depth
      depthTest: true         // Nh∆∞ng v·∫´n test depth
    });

    // Bi·∫øn ƒë·ªÉ l∆∞u face mask geometry
    let faceMaskGeometry = null;
    let faceMaskMesh = null;
    
    // üé≠ MANUAL STENCIL BUFFER SETUP
    // T·∫°o separate scenes ƒë·ªÉ control stencil passes
    const headScene = new THREE.Scene();
    const hatScene = new THREE.Scene();
    
    // Copy lights sang c·∫£ 2 scenes
    const headLight = light.clone();
    const headDirectionalLight = directionalLight.clone();
    headScene.add(headLight);
    headScene.add(headDirectionalLight);
    
    const hatLight = light.clone();
    const hatDirectionalLight = directionalLight.clone();
    hatScene.add(hatLight);
    hatScene.add(hatDirectionalLight);

    // ---- Head Occluder v·ªõi Manual Stencil ----
    const headProxy = new THREE.Group();
    
    // Stencil material cho head occluder
    const stencilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    stencilMat.colorWrite = false;
    stencilMat.depthWrite = true;

    const headOccluder = new THREE.Mesh(
      new THREE.SphereGeometry(0.5, 32, 32),
      stencilMat
    );
    headOccluder.name = 'headOccluder';
    headProxy.add(headOccluder);
    headScene.add(headProxy); // Th√™m v√†o headScene
    
    // üé≠ Depth Masking Controls Variables
    let enableDepthMask = true;
     let enableHeadReplacement = false;
     let enableHeadCenterForGlasses = false; // Option to use head center for glasses
    let showFaceMaskDebug = false;
     let showHeadOccluderDebug = false;
     let headOccluderSizeMultiplier = 0.34;
     let headProxyScaleSensitivity = 2; // ƒê·ªô nh·∫°y scale c·ªßa head proxy

    // Create reference line (horizontal line perpendicular to nose bridge)
    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-2, 0, 0),
      new THREE.Vector3(2, 0, 0)
    ]);
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
    const referenceLine = new THREE.Line(lineGeometry, lineMaterial);
    scene.add(referenceLine);

    // T·∫°o ƒë∆∞·ªùng th·∫≥ng t·ª´ c·∫±m ƒë·∫øn gi·ªØa l√¥ng m√†y song song v·ªõi tr·ª•c Oy
    const chinToEyebrowGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0.8, 0),  // ƒêi·ªÉm tr√™n (l√¥ng m√†y)
      new THREE.Vector3(0, 0.4, 0),
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(0, -0.4, 0),
      new THREE.Vector3(0, -0.8, 0)  // ƒêi·ªÉm d∆∞·ªõi (c·∫±m)
    ]);
    const chinToEyebrowMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 4 });
    const chinToEyebrowLine = new THREE.Line(chinToEyebrowGeometry, chinToEyebrowMaterial);
    scene.add(chinToEyebrowLine);

    // T·∫°o ƒë∆∞·ªùng l√¥ng m√†y (eyebrow line) - c·∫£i ti·∫øn v·ªõi ƒë∆∞·ªùng cong
    const eyebrowGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-1.2, 0.1, 0),
      new THREE.Vector3(-0.8, 0.15, 0),
      new THREE.Vector3(-0.4, 0.2, 0),
      new THREE.Vector3(0, 0.25, 0),
      new THREE.Vector3(0.4, 0.2, 0),
      new THREE.Vector3(0.8, 0.15, 0),
      new THREE.Vector3(1.2, 0.1, 0)
    ]);
    const eyebrowMaterial = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 4 });
    const eyebrowLine = new THREE.Line(eyebrowGeometry, eyebrowMaterial);
    scene.add(eyebrowLine);

    // T·∫°o ƒë∆∞·ªùng m·∫Øt (eye line) - ƒë∆∞·ªùng cong m·∫Øt
    const eyeGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-1.5, -0.1, 0),
      new THREE.Vector3(-1.2, -0.15, 0),
      new THREE.Vector3(-0.8, -0.2, 0),
      new THREE.Vector3(-0.4, -0.25, 0),
      new THREE.Vector3(0, -0.3, 0),
      new THREE.Vector3(0.4, -0.25, 0),
      new THREE.Vector3(0.8, -0.2, 0),
      new THREE.Vector3(1.2, -0.15, 0),
      new THREE.Vector3(1.5, -0.1, 0)
    ]);
    const eyeMaterial = new THREE.LineBasicMaterial({ color: 0xff00ff, linewidth: 3 });
    const eyeLine = new THREE.Line(eyeGeometry, eyeMaterial);
    scene.add(eyeLine);

    // T·∫°o ƒë∆∞·ªùng mi·ªáng (mouth line) - ƒë∆∞·ªùng cong mi·ªáng
    const mouthGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-1.0, -0.8, 0),
      new THREE.Vector3(-0.6, -0.9, 0),
      new THREE.Vector3(-0.2, -1.0, 0),
      new THREE.Vector3(0, -1.1, 0),
      new THREE.Vector3(0.2, -1.0, 0),
      new THREE.Vector3(0.6, -0.9, 0),
      new THREE.Vector3(1.0, -0.8, 0)
    ]);
    const mouthMaterial = new THREE.LineBasicMaterial({ color: 0xff8800, linewidth: 3 });
    const mouthLine = new THREE.Line(mouthGeometry, mouthMaterial);
    scene.add(mouthLine);

    // T·∫°o c√°c outline mesh cho c√°c v√πng khu√¥n m·∫∑t
    const createOutlineMesh = (color, size = 0.1, shape = 'ring') => {
      let geometry;
      
      if (shape === 'ring') {
        geometry = new THREE.RingGeometry(size * 0.8, size, 32);
      } else if (shape === 'ellipse') {
        geometry = new THREE.RingGeometry(size * 0.6, size, 32);
        geometry.scale(1.5, 1, 1); // L√†m d·∫πt ƒë·ªÉ t·∫°o h√¨nh ellipse
      } else if (shape === 'oval') {
        geometry = new THREE.RingGeometry(size * 0.7, size, 32);
        geometry.scale(2, 1, 1); // L√†m d·∫πt h∆°n cho l√¥ng m√†y
      }
      
      const material = new THREE.MeshBasicMaterial({ 
        color: color, 
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.8
      });
      return new THREE.Mesh(geometry, material);
    };

    // T·∫°o c√°c outline cho c√°c v√πng v·ªõi h√¨nh d·∫°ng ph√π h·ª£p
    const noseOutline = createOutlineMesh(0x00ffff, 0.15, 'ring'); // H√¨nh tr√≤n cho m≈©i
    const leftEyeOutline = createOutlineMesh(0xff00ff, 0.12, 'ellipse'); // H√¨nh ellipse cho m·∫Øt
    const rightEyeOutline = createOutlineMesh(0xff00ff, 0.12, 'ellipse');
    const leftEyebrowOutline = createOutlineMesh(0xffff00, 0.18, 'oval'); // H√¨nh oval cho l√¥ng m√†y
    const rightEyebrowOutline = createOutlineMesh(0xffff00, 0.18, 'oval');
    const mouthOutline = createOutlineMesh(0xff8800, 0.25, 'ellipse'); // H√¨nh ellipse cho mi·ªáng
    
    scene.add(noseOutline);
    scene.add(leftEyeOutline);
    scene.add(rightEyeOutline);
    scene.add(leftEyebrowOutline);
    scene.add(rightEyebrowOutline);
    scene.add(mouthOutline);

    // T·∫°o tr·ª•c t·ªça ƒë·ªô ri√™ng cho model
    const modelAxes = new THREE.Group();
    
    // Tr·ª•c X (ƒë·ªè)
    const xAxisGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(1.5, 0, 0)
    ]);
    const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
    const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
    modelAxes.add(xAxis);
    
    // Tr·ª•c Y (xanh l√°)
    const yAxisGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(0, 1.5, 0)
    ]);
    const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
    const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
    modelAxes.add(yAxis);
    
    // Tr·ª•c Z (xanh d∆∞∆°ng)
    const zAxisGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(0, 0, 1.5)
    ]);
    const zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 3 });
    const zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
    modelAxes.add(zAxis);
    
    // Th√™m nh√£n cho c√°c tr·ª•c
    const createAxisLabel = (text, color, position) => {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 64;
      canvas.height = 64;
      context.fillStyle = color;
      context.font = '48px Arial';
      context.textAlign = 'center';
      context.fillText(text, 32, 40);
      
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(material);
      sprite.position.copy(position);
      sprite.scale.set(0.3, 0.3, 0.3);
      return sprite;
    };
    
    modelAxes.add(createAxisLabel('X', '#ff0000', new THREE.Vector3(1.8, 0, 0)));
    modelAxes.add(createAxisLabel('Y', '#00ff00', new THREE.Vector3(0, 1.8, 0)));
    modelAxes.add(createAxisLabel('Z', '#0000ff', new THREE.Vector3(0, 0, 1.8)));
    
    // Pivot point indicator (yellow sphere at origin)
    const pivotGeometry = new THREE.SphereGeometry(0.03, 8, 8);
    const pivotMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xffff00, 
      transparent: true, 
      opacity: 0.8 
    });
    const pivotIndicator = new THREE.Mesh(pivotGeometry, pivotMaterial);
    pivotIndicator.name = 'pivotIndicator';
    modelAxes.add(pivotIndicator);
    
    hatScene.add(modelAxes); // Th√™m v√†o hatScene

    // Variables with settings
    let currentRotation = { x: 0, y: 0, z: 0 };
    let targetRotation = { x: 0, y: 0, z: 0 };
    let smoothingFactor = 0.4; // TƒÉng ƒë·ªÉ tracking m∆∞·ª£t m√† v√† t·ª± nhi√™n h∆°n
    
    // Dynamic scaling settings
    let modelScaleBoost = 1.0; // Additional scale multiplier for real-time adjustment
    
    // Variables for position tracking fallback
    let lastKnownPosition = { x: 0, y: 0, z: 0 };
    let trackingLostFrames = 0;
    const maxTrackingLostFrames = 30; // Gi·ªØ v·ªã tr√≠ cu·ªëi trong 30 frames
    let edgeTrackingSensitivity = 0.1; // ƒê·ªô nh·∫°y tracking ·ªü r√¨a m√†n h√¨nh
         let showMesh = true;
     let showMeshTesselation = true;
     let showMeshContours = true;
     let showMeshIrises = true;
     let showAxes = true;

    
    
    
    // Glasses settings
    let glassesYOffset = 0.05;
    
    // Hat settings
    let hatYOffset = -0.1; // Offset from forehead position

    // Load saved settings from localStorage
    function loadSettings() {
      const savedSettings = localStorage.getItem('hatTrackingSettings');
      if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        smoothingFactor = settings.smoothingFactor || 0.4;
                 showMesh = settings.showMesh !== undefined ? settings.showMesh : true;
         showMeshTesselation = settings.showMeshTesselation !== undefined ? settings.showMeshTesselation : true;
         showMeshContours = settings.showMeshContours !== undefined ? settings.showMeshContours : true;
         showMeshIrises = settings.showMeshIrises !== undefined ? settings.showMeshIrises : true;
         showAxes = settings.showAxes !== undefined ? settings.showAxes : true;

         edgeTrackingSensitivity = settings.edgeTrackingSensitivity || 0.1;
         enableHeadReplacement = settings.enableHeadReplacement !== undefined ? settings.enableHeadReplacement : false;
         
                 // Load glasses settings
        glassesYOffset = settings.glassesYOffset || 0.05;
        
        // Load hat settings
        hatYOffset = settings.hatYOffset || -0.1;
        
        // Load model scale boost
        modelScaleBoost = settings.modelScaleBoost || 1.0;
        
        // Load head proxy scale sensitivity
        headProxyScaleSensitivity = settings.headProxyScaleSensitivity || 0.8;
      }
    }

    // Save settings to localStorage
    function saveSettings() {
      const settings = {
        smoothingFactor: smoothingFactor,
        showMesh: showMesh,
        showMeshTesselation: showMeshTesselation,
        showMeshContours: showMeshContours,
        showMeshIrises: showMeshIrises,
        showAxes: showAxes,
        edgeTrackingSensitivity: edgeTrackingSensitivity,
        glassesYOffset: glassesYOffset,
         hatYOffset: hatYOffset,
         modelScaleBoost: modelScaleBoost,
         enableHeadReplacement: enableHeadReplacement,
         headProxyScaleSensitivity: headProxyScaleSensitivity
      };
      localStorage.setItem('hatTrackingSettings', JSON.stringify(settings));
      console.log('Settings saved:', settings);
    }

    // Reset settings to default
    function resetSettings() {
      smoothingFactor = 0.4;
      showMesh = true;
      showMeshTesselation = true;
      showMeshContours = true;
      showMeshIrises = true;
      showAxes = true;
      edgeTrackingSensitivity = 0.1;
      
      // Reset glasses settings
      glassesYOffset = 0.05;
      
      // Reset model scale boost
      modelScaleBoost = 1.0;
      
      // Reset head proxy scale sensitivity
      headProxyScaleSensitivity = 0.8;
      
      // Reset head detection for re-scaling
      resetHeadDetection();
      
      // Remove saved settings
      localStorage.removeItem('hatTrackingSettings');
      
      console.log('Settings reset to default');
    }
    

//#endregion 
function logModelSize(model, label = 'Model') {
  const box = new THREE.Box3().setFromObject(model);
  const size = new THREE.Vector3();
  box.getSize(size);
  const maxDim = Math.max(size.x, size.y, size.z);

  console.log(`üì¶ K√≠ch th∆∞·ªõc ${label} sau khi scale:`);
  console.log(`  x: ${size.x.toFixed(3)}, y: ${size.y.toFixed(3)}, z: ${size.z.toFixed(3)}`);
  console.log(`  maxDim: ${maxDim.toFixed(3)}`);
  
  // Log scale correction info if available
  if (model.userData) {
    if (model.userData.originalMaxDim) {
      console.log(`  originalMaxDim: ${model.userData.originalMaxDim.toFixed(3)}`);
    }
    if (model.userData.scaleCorrection) {
      console.log(`  scaleCorrection: ${model.userData.scaleCorrection.toFixed(6)}`);
    }
    if (model.userData.normalizedScale) {
      console.log(`  normalizedScale: ${model.userData.normalizedScale.toFixed(6)}`);
    }
  }
}
  // Model size configuration - ƒë·ªãnh nghƒ©a k√≠ch th∆∞·ªõc chu·∫©n cho t·ª´ng lo·∫°i model
  const modelSizeConfig = {
      hat: 1,        // K√≠ch th∆∞·ªõc chu·∫©n cho hat
      glasses: 1.5,   // K√≠ch th∆∞·ªõc chu·∫©n cho glasses
      fallbackHat: 0.2,
      fallbackGlasses: 0.15
    };
    // Enhanced function to normalize model scale and store fixed size
  function smartNormalizeModelScale(model, targetSize = 0.2, tolerance = 0.05) {
  // ƒê·∫£m b·∫£o bounding box l·∫•y ƒë√∫ng to√†n b·ªô model (bao g·ªìm c·∫£ con)
  model.updateMatrixWorld(true);

  const box = new THREE.Box3().setFromObject(model);
  const size = new THREE.Vector3();
  box.getSize(size);
  const maxDim = Math.max(size.x, size.y, size.z);
  
  // N·∫øu model qu√° nh·ªè ho·∫∑c ch∆∞a load xong, c·∫£nh b√°o
  if (maxDim < 1e-6) {
    console.warn('‚ö†Ô∏è Model qu√° nh·ªè ho·∫∑c ch∆∞a load xong, kh√¥ng th·ªÉ normalize.');
    return;
  }
  
  // Calculate initial scale to normalize to targetSize
  let scale = targetSize / maxDim;
  
  // üéØ IMPORTANT: X·ª≠ l√Ω model c√≥ k√≠ch th∆∞·ªõc g·ªëc qu√° l·ªõn HO·∫∂C qu√° nh·ªè
  let scaleCorrection = 1.0;
  let correctionReason = "Normal size";
  
  if (maxDim >= 100) {
    scaleCorrection = 0.08; // Model r·∫•t l·ªõn, gi·∫£m m·∫°nh
    correctionReason = "Very large model (>=100)";
  } else if (maxDim >= 50) {
    scaleCorrection = 0.5; // Model l·ªõn, gi·∫£m v·ª´a
    correctionReason = "Large model (>=50)";
  } else if (maxDim < 0.1) {
    scaleCorrection = 0.3; // Model r·∫•t nh·ªè, gi·∫£m scale ƒë·ªÉ tr√°nh ph√≥ng to qu√° m·ª©c
    correctionReason = "Very small model (<0.1)";
  } else if (maxDim < 1) {
    scaleCorrection = 0.7; // Model nh·ªè, gi·∫£m nh·∫π
    correctionReason = "Small model (<1)";
  } else if (maxDim < 10) {
    scaleCorrection = 0.9; // Model h∆°i nh·ªè, gi·∫£m r·∫•t nh·∫π
    correctionReason = "Medium-small model (<10)";
  }
  
  // √Åp d·ª•ng scale correction
  scale *= scaleCorrection;

  // Validate scale kh√¥ng qu√° nh·ªè ho·∫∑c qu√° l·ªõn
  const minScale = 0.001;
  const maxScale = 1000; // Gi·ªõi h·∫°n scale t·ªëi ƒëa ƒë·ªÉ tr√°nh l·ªói
  
  if (scale < minScale) {
    console.warn(`‚ö†Ô∏è Scale qu√° nh·ªè (${scale.toFixed(6)}), ƒë·∫∑t v·ªÅ gi√° tr·ªã t·ªëi thi·ªÉu ${minScale}`);
    scale = minScale;
  } else if (scale > maxScale) {
    console.warn(`‚ö†Ô∏è Scale qu√° l·ªõn (${scale.toFixed(6)}), ƒë·∫∑t v·ªÅ gi√° tr·ªã t·ªëi ƒëa ${maxScale}`);
    scale = maxScale;
  }

  model.scale.set(scale, scale, scale);

  // Store the normalized scale and correction for consistent sizing
  model.userData.normalizedScale = scale;
  model.userData.targetSize = targetSize;
  model.userData.originalMaxDim = maxDim;
  model.userData.scaleCorrection = scaleCorrection;
  model.userData.correctionReason = correctionReason;

  console.log(`‚úÖ Model chu·∫©n h√≥a: scale=${scale.toFixed(6)}, targetSize=${targetSize}, maxDim=${maxDim.toFixed(3)}`);
  console.log(`   üîß Scale correction: ${scaleCorrection} (${correctionReason})`);
  console.log(`   üìä Scale ratio: ${(scale/targetSize).toFixed(2)}x`);
  
  logModelSize(model);
}


    // Function to apply dynamic scaling per frame
    function applyDynamicScalePerFrame(model, headFit, modelType = 'hat') {
      if (!model || !headFit) return;
      
      // Calculate appropriate scale based on head size
      const headScale = Math.min(headFit.width, headFit.height);
      let scaleMultiplier;
      
             // Different scale multipliers for different model types
       switch(modelType) {
         case 'hat':
           scaleMultiplier = 4;
           break;
         case 'glasses':
           scaleMultiplier = 1.2;
           break;
         default:
           scaleMultiplier = 3.5;
       }
      
      // üéØ IMPORTANT: S·ª≠ d·ª•ng scale correction t·ª´ normalize ƒë·ªÉ tr√°nh model qu√° to
      let correctionFactor = 1.0;
      if (model.userData && model.userData.scaleCorrection) {
        correctionFactor = model.userData.scaleCorrection;
        
        // ƒêi·ªÅu ch·ªânh th√™m multiplier d·ª±a tr√™n k√≠ch th∆∞·ªõc g·ªëc c·ªßa model
        const originalMaxDim = model.userData.originalMaxDim || 1;
        console.log("originalMaxDim la: " + originalMaxDim);
        if (originalMaxDim >= 100) {
          scaleMultiplier *= 0.15; // Gi·∫£m th√™m cho model r·∫•t l·ªõn
        } else if (originalMaxDim >= 50) {
          scaleMultiplier *= 0.08; // Gi·∫£m th√™m cho model l·ªõn
        } else if (originalMaxDim < 0.1) {
          scaleMultiplier *= 2.0; // TƒÉng th√™m cho model r·∫•t nh·ªè
        } else if (originalMaxDim < 1) {
          scaleMultiplier *= 6.5; // TƒÉng th√™m cho model nh·ªè
        } else if (originalMaxDim < 10) {
          scaleMultiplier *= 1.2; // TƒÉng nh·∫π cho model h∆°i nh·ªè
        }
      }
      
      const finalScale = headScale * scaleMultiplier * correctionFactor * modelScaleBoost;
      
      // Apply scale with smoothing for stable animation
      const targetScale = new THREE.Vector3(finalScale, finalScale, finalScale);
      model.scale.lerp(targetScale, smoothingFactor * 0.5); // Slower smoothing for scale
      
      // Store current scale for debugging
      model.userData.currentDynamicScale = finalScale;
      
      // Update debug info occasionally (not every frame for performance)
      if (Math.random() < 0.01) { // 1% c·ªßa frames
        const debugElement = document.getElementById('scale-debug');
        if (debugElement) {
          const originalMaxDim = model.userData.originalMaxDim || 'unknown';
          const correctionReason = model.userData.correctionReason || "Unknown";
          debugElement.innerHTML = `
            ${modelType}: headScale=${headScale.toFixed(3)}, multiplier=${scaleMultiplier.toFixed(2)}, correction=${correctionFactor.toFixed(4)}, originalMaxDim=${originalMaxDim}, final=${finalScale.toFixed(3)}
            <br>üìè Model size: ${correctionReason}
          `;
        }
      }
    }

    // Load the low-poly hat model
    const loader = new THREE.GLTFLoader();
    let hatModel;
    
    // Create a fallback hat model in case GLTF fails to load
    const createFallbackHat = () => {
      const geometry = new THREE.ConeGeometry(0.5, 1, 8);
      const material = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
      const fallbackHat = new THREE.Mesh(geometry, material);
      fallbackHat.rotation.x = Math.PI / 2;
      return fallbackHat;
    };
    
    // T·∫°o model t·∫°m th·ªùi ngay l·∫≠p t·ª©c ƒë·ªÉ test
    hatModel = createFallbackHat();
    smartNormalizeModelScale(hatModel, modelSizeConfig.fallbackHat); // Normalize fallback model
    hatScene.add(hatModel); // Th√™m v√†o hatScene
    
    loader.load(
      'assets/low_poly_hat/hat.gltf',
      (gltf) => {
        // Remove temporary model
        hatScene.remove(hatModel);
        // Add real model
        hatModel = gltf.scene;
        
        // Normalize model scale to ensure consistent size across different models
        smartNormalizeModelScale(hatModel, modelSizeConfig.hat);
        
        hatModel.rotation.set(0, 0, 0);
        hatScene.add(hatModel); // Th√™m v√†o hatScene
        console.log('‚úÖ Hat model loaded and scale normalized - will use dynamic scaling per frame');
      },
      (xhr) => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
      (error) => {
        console.error('Error loading GLTF model:', error);
      }
    );

    // Load the glasses model
    let glassesModel;
    
    // Create a fallback glasses model in case GLTF fails to load
    const createFallbackGlasses = () => {
      const geometry = new THREE.RingGeometry(0.3, 0.4, 8);
      const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const fallbackGlasses = new THREE.Mesh(geometry, material);
      fallbackGlasses.rotation.x = Math.PI / 2;
      return fallbackGlasses;
    };
    
    // T·∫°o model t·∫°m th·ªùi ngay l·∫≠p t·ª©c ƒë·ªÉ test
    glassesModel = createFallbackGlasses();
    smartNormalizeModelScale(glassesModel, modelSizeConfig.fallbackGlasses); // Normalize fallback model
    hatScene.add(glassesModel); // Th√™m v√†o hatScene
    
    loader.load(
      'assets/low_poly_hat/sun_glasses.glb',
      (gltf) => {
        // Remove temporary model
        hatScene.remove(glassesModel);
        // Add real model
        glassesModel = gltf.scene;
        
        // Normalize model scale to ensure consistent size across different models
        smartNormalizeModelScale(glassesModel, modelSizeConfig.glasses);
        
        // Apply initial rotation to fix mirror effect - flip the model 180 degrees around Y-axis
        glassesModel.rotation.set(0, 0, 0);
        // glassesModel.rotation.y = Math.PI;
        hatScene.add(glassesModel); // Th√™m v√†o hatScene
        console.log('‚úÖ Glasses model loaded, scale normalized - will use dynamic scaling per frame');
      },
      (xhr) => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
      (error) => {
        console.error('Error loading glasses GLTF model:', error);
      }
    );

    // Function to calculate head size and position from landmarks - tracking theo forehead
    function calculateHeadFit(landmarks) {
      // Get key landmarks for head size calculation with fallbacks
      const leftEar = landmarks[234] || landmarks[227]; // Left ear with fallback
      const rightEar = landmarks[454] || landmarks[447]; // Right ear with fallback
      const leftEye = landmarks[33] || landmarks[7]; // Left eye with fallback
      const rightEye = landmarks[263] || landmarks[249]; // Right eye with fallback
      const nose = landmarks[1] || landmarks[4]; // Nose tip with fallback
      const chin = landmarks[152] || landmarks[175]; // Chin with fallback
      const forehead = landmarks[10] || landmarks[151]; // Forehead with fallback
      const leftCheek = landmarks[123] || landmarks[50]; // Left cheek with fallback
      const rightCheek = landmarks[352] || landmarks[280]; // Right cheek with fallback

      // Validate landmarks exist and are within reasonable bounds
      const isValidLandmark = (landmark) => {
        return landmark && 
               landmark.x >= 0 && landmark.x <= 1 && 
               landmark.y >= 0 && landmark.y <= 1 && 
               landmark.z >= -1 && landmark.z <= 1;
      };

      // Use fallback calculation if ears are not reliable (common at screen edges)
      let headWidth, headHeight, headDepth;
      
      if (isValidLandmark(leftEar) && isValidLandmark(rightEar)) {
        // Use ear-to-ear width if available
        headWidth = Math.abs(leftEar.x - rightEar.x);
        headDepth = Math.abs(leftEar.z - rightEar.z);
      } else {
        // Fallback to eye-to-eye width
        headWidth = Math.abs(leftEye.x - rightEye.x) * 1.5; // Scale up since eyes are closer
        headDepth = Math.abs(leftEye.z - rightEye.z) * 1.5;
      }
      
      // Calculate head height (forehead to chin)
      if (isValidLandmark(forehead) && isValidLandmark(chin)) {
        headHeight = Math.abs(forehead.y - chin.y);
      } else {
        // Fallback to nose-based height
        const noseTop = landmarks[168] || landmarks[6]; // Top of nose
        const noseBottom = landmarks[2] || landmarks[1]; // Bottom of nose
        headHeight = Math.abs(noseTop.y - noseBottom.y) * 3; // Scale up
      }
      
      // Use forehead position with fallback to nose
      let centerX, centerY, centerZ;
      if (isValidLandmark(forehead)) {
        centerX = forehead.x;
        centerY = forehead.y;
        centerZ = forehead.z;
      } else if (isValidLandmark(nose)) {
        // Use nose position and adjust Y upward to approximate forehead
        centerX = nose.x;
        centerY = nose.y - 0.1; // Move up to approximate forehead
        centerZ = nose.z;
      } else {
        // Last resort: use center of available landmarks
        const validLandmarks = [leftEye, rightEye, leftCheek, rightCheek].filter(isValidLandmark);
        if (validLandmarks.length > 0) {
          centerX = validLandmarks.reduce((sum, lm) => sum + lm.x, 0) / validLandmarks.length;
          centerY = validLandmarks.reduce((sum, lm) => sum + lm.y, 0) / validLandmarks.length;
          centerZ = validLandmarks.reduce((sum, lm) => sum + lm.z, 0) / validLandmarks.length;
        } else {
          // Default to center of screen
          centerX = 0.5;
          centerY = 0.5;
          centerZ = 0;
        }
      }

      return {
        width: headWidth || 0.3, // Default width if calculation fails
        height: headHeight || 0.4, // Default height if calculation fails
        depth: headDepth || 0.1, // Default depth if calculation fails
        center: { x: centerX, y: centerY, z: centerZ }
      };
    }

    // Function to calculate true head center (pivot point) from landmarks
    function calculateTrueHeadCenter(landmarks) {
      try {
        // Key landmarks for head center calculation
        const leftEar = landmarks[234];   // Left ear
        const rightEar = landmarks[454];  // Right ear
        const forehead = landmarks[10];   // Forehead center
        const chin = landmarks[152];      // Chin center
        const noseTop = landmarks[168];   // Nose bridge
        
        if (!leftEar || !rightEar || !forehead || !chin) {
          console.warn('Missing key landmarks for head center calculation');
          return null;
        }
        
        // Calculate center point between ears (X center)
        const earCenterX = (leftEar.x + rightEar.x) / 2;
        const earCenterZ = (leftEar.z + rightEar.z) / 2;
        
        // Calculate center point between forehead and chin (Y center)
        const faceCenterY = (forehead.y + chin.y) / 2;
        
        // Use nose bridge Z as reference depth and move back slightly into head
        const headCenterZ = (noseTop.z || 0) - 0.02; // Move 2cm back into head
        
        return {
          x: earCenterX,
          y: faceCenterY,
          z: headCenterZ
        };
      } catch (error) {
        console.error('Error calculating true head center:', error);
        return null;
      }
    }

    // Function to calculate head rotation matrix using the new method
    function calculateHeadRotationMatrix(landmarks) {
      // C√°c ƒëi·ªÉm landmark ch√≠nh
      const leftEar = landmarks[234];
      const rightEar = landmarks[454];
      const forehead = landmarks[10];
      const chin = landmarks[152];

      // 1. T√≠nh tr·ª•c X: t·ª´ tai ph·∫£i sang tai tr√°i (right ‚Üí left) - ƒë·∫£o ng∆∞·ª£c ƒë·ªÉ s·ª≠a h∆∞·ªõng
      const xDir = new THREE.Vector3(
        leftEar.x - rightEar.x,
        leftEar.y - rightEar.y,
        leftEar.z - rightEar.z
      ).normalize();

      // 2. T√≠nh tr·ª•c Y: t·ª´ tr√°n ƒë·∫øn c·∫±m (forehead ‚Üí chin)
      const yDir = new THREE.Vector3(
        forehead.x - chin.x,
        forehead.y - chin.y,
        forehead.z - chin.z
      ).normalize();

      // 3. T√≠nh tr·ª•c Z: vu√¥ng g√≥c m·∫∑t h∆∞·ªõng ra ngo√†i (Z = -(X √ó Y))
      const zDir = new THREE.Vector3().crossVectors(xDir, yDir).normalize().multiplyScalar(-1);

      // Re-orthogonalize Y ƒë·ªÉ ƒë·∫£m b·∫£o tr·ª±c giao (Y = Z √ó X)
      yDir.crossVectors(zDir, xDir).normalize();

      // T·∫°o ma tr·∫≠n quay 3D
      const rotationMatrix = new THREE.Matrix4();
      rotationMatrix.makeBasis(xDir, yDir, zDir); // X: ngang, Y: d·ªçc m·∫∑t, Z: h∆∞·ªõng ra

      return rotationMatrix;
    }

    // Function to calculate head rotation from landmarks using new matrix-based method
    function calculateHeadRotation(landmarks) {
      try {
        // Validate landmarks
        if (!landmarks || landmarks.length < 468) {
          console.warn('Invalid landmarks for head rotation calculation');
          return { x: 0, y: 0, z: 0 };
        }

        // Use new matrix-based calculation
        const rotationMatrix = calculateHeadRotationMatrix(landmarks);
        
        // Extract Euler angles from rotation matrix
        const euler = new THREE.Euler();
        euler.setFromRotationMatrix(rotationMatrix);
        
        // Validate Euler angles
        if (isNaN(euler.x) || isNaN(euler.y) || isNaN(euler.z)) {
          console.warn('Invalid Euler angles from matrix, using fallback');
          throw new Error('Invalid Euler angles');
        }

                        // Apply smoothing
                const smoothingFactor = 0.3;
                currentRotation.x += (euler.x - currentRotation.x) * smoothingFactor;
                currentRotation.y += (euler.y - currentRotation.y) * smoothingFactor;
                currentRotation.z += (euler.z - currentRotation.z) * smoothingFactor;

        return currentRotation;
      } catch (error) {
        console.warn('Matrix calculation failed, using fallback method:', error);
        
        // Fallback to old method
        try {
          const nose = landmarks[1]; // Nose tip
          const leftEye = landmarks[33]; // Left eye
          const rightEye = landmarks[263]; // Right eye
          const leftEar = landmarks[234]; // Left ear
          const rightEar = landmarks[454]; // Right ear
          const forehead = landmarks[10]; // Forehead
          const chin = landmarks[152]; // Chin

          // Ki·ªÉm tra landmarks c√≥ h·ª£p l·ªá kh√¥ng
          if (!nose || !leftEye || !rightEye || !leftEar || !rightEar || !forehead || !chin) {
            console.warn('Missing landmarks for fallback method');
            return { x: 0, y: 0, z: 0 };
          }

          // Calculate head rotation around Y-axis (left-right) - ƒë·∫£o ng∆∞·ª£c cho camera mirror
          const eyeCenterX = (leftEye.x + rightEye.x) / 2;
          const earCenterX = (leftEar.x + rightEar.x) / 2;
          const headWidth = Math.abs(leftEar.x - rightEar.x);
          const yRotation = -Math.atan2(eyeCenterX - earCenterX, headWidth * 0.25);

          // Calculate head rotation around X-axis (up-down) - tracking t·ª± nhi√™n h∆°n
          const eyeCenterY = (leftEye.y + rightEye.y) / 2;
          const noseY = nose.y;
          const headHeight = Math.abs(forehead.y - chin.y);
          const xRotation = Math.atan2(noseY - eyeCenterY, headHeight * 0.4);

                            // Apply smoothing
                  const smoothingFactor = 0.3;
                  currentRotation.x += (xRotation - currentRotation.x) * smoothingFactor;
                  currentRotation.y += (yRotation - currentRotation.y) * smoothingFactor;
                  currentRotation.z += (0 - currentRotation.z) * smoothingFactor;

          return currentRotation;
        } catch (fallbackError) {
          console.error('Both matrix and fallback methods failed:', fallbackError);
          return { x: 0, y: 0, z: 0 };
        }
      }
    }

    // Function to calculate nose bridge direction from mesh data
    function calculateNoseBridgeFromMesh(landmarks) {
      // Define nose bridge landmark indices based on MediaPipe FaceMesh
      // These are the key points that form the nose bridge from forehead to nose tip
      const noseBridgePoints = [
        10,   // Forehead center
        151,  // Upper nose bridge
        9,    // Upper nose bridge
        8,    // Upper nose bridge
        168,  // Upper nose bridge
        6,    // Middle nose bridge
        197,  // Middle nose bridge
        196,  // Middle nose bridge
        3,    // Lower nose bridge
        51,   // Lower nose bridge
        1     // Nose tip
      ];
      
      // Filter valid points and calculate center line
      const validPoints = [];
      for (const pointIndex of noseBridgePoints) {
        if (landmarks[pointIndex]) {
          validPoints.push(landmarks[pointIndex]);
        }
      }
      
      if (validPoints.length < 3) {
        console.warn('Not enough valid nose bridge points');
        return { x: 0, y: 1 }; // Default vertical direction
      }
      
      // Calculate the main direction vector from forehead to nose tip
      const startPoint = validPoints[0]; // Forehead
      const endPoint = validPoints[validPoints.length - 1]; // Nose tip
      
      const bridgeVectorX = endPoint.x - startPoint.x;
      const bridgeVectorY = endPoint.y - startPoint.y;
      
      // Calculate perpendicular vector (90 degrees rotation)
      const perpVectorX = -bridgeVectorY;
      const perpVectorY = bridgeVectorX;
      
      // Normalize the perpendicular vector
      const length = Math.sqrt(perpVectorX * perpVectorX + perpVectorY * perpVectorY);
      if (length === 0) {
        return { x: 0, y: 1 }; // Default vertical direction
      }
      
      const normalizedPerpX = perpVectorX / length;
      const normalizedPerpY = perpVectorY / length;
      
      return { x: normalizedPerpX, y: normalizedPerpY };
    }

    // Advanced function to extract nose bridge from FACEMESH_TESSELATION connections
    function extractNoseBridgeFromTesselation(landmarks) {
      // Define the key nose bridge points using the specific indices provided by user
      const noseBridgeSequence = [
        168,  // Upper nose bridge
        6,    // Middle nose bridge
        197,  // Middle nose bridge
        195,  // Lower nose bridge
        1     // Nose tip
      ];
      
      // Find valid points in sequence
      const validSequence = [];
      for (const pointIndex of noseBridgeSequence) {
        if (landmarks[pointIndex]) {
          validSequence.push({
            index: pointIndex,
            point: landmarks[pointIndex]
          });
        }
      }
      
      if (validSequence.length < 3) {
        console.warn('Not enough valid nose bridge sequence points');
        return null;
      }
      
      // Calculate the center line of the nose bridge
      const centerPoints = [];
      for (let i = 0; i < validSequence.length; i++) {
        const current = validSequence[i];
        
        // For each point, calculate its position along the nose bridge
        const progress = i / (validSequence.length - 1); // 0 to 1
        
        // Add some smoothing by averaging with neighboring points
        let avgX = current.point.x;
        let avgY = current.point.y;
        let avgZ = current.point.z;
        let count = 1;
        
        // Average with previous point if available
        if (i > 0) {
          const prev = validSequence[i - 1];
          avgX += prev.point.x;
          avgY += prev.point.y;
          avgZ += prev.point.z;
          count++;
        }
        
        // Average with next point if available
        if (i < validSequence.length - 1) {
          const next = validSequence[i + 1];
          avgX += next.point.x;
          avgY += next.point.y;
          avgZ += next.point.z;
          count++;
        }
        
        centerPoints.push({
          x: avgX / count,
          y: avgY / count,
          z: avgZ / count,
          progress: progress
        });
      }
      
      return centerPoints;
    }

    // Function to calculate nose bridge direction for reference line
    function calculateNoseBridgeDirection(landmarks) {
      // Try the advanced mesh-based extraction first
      const noseBridgeLine = extractNoseBridgeFromTesselation(landmarks);
      
      if (noseBridgeLine && noseBridgeLine.length >= 2) {
        // Use the extracted nose bridge line to calculate direction
        const startPoint = noseBridgeLine[0];
        const endPoint = noseBridgeLine[noseBridgeLine.length - 1];
        
        const bridgeVectorX = endPoint.x - startPoint.x;
        const bridgeVectorY = endPoint.y - startPoint.y;
        
        // Calculate perpendicular vector (90 degrees rotation)
        const perpVectorX = -bridgeVectorY;
        const perpVectorY = bridgeVectorX;
        
        // Normalize the perpendicular vector
        const length = Math.sqrt(perpVectorX * perpVectorX + perpVectorY * perpVectorY);
        if (length > 0) {
          const normalizedPerpX = perpVectorX / length;
          const normalizedPerpY = perpVectorY / length;
          return { x: normalizedPerpX, y: normalizedPerpY };
        }
      }
      
      // Fallback to the simpler mesh-based calculation
      return calculateNoseBridgeFromMesh(landmarks);
    }

    // Helper: kho·∫£ng c√°ch world gi·ªØa 2 landmark
    function worldDistance(lmA, lmB) {
      const a = mapToThreeJS(lmA.x, lmA.y, lmA.z, true);
      const b = mapToThreeJS(lmB.x, lmB.y, lmB.z, true);
      const va = new THREE.Vector3(a.x, a.y, a.z);
      const vb = new THREE.Vector3(b.x, b.y, b.z);
      return va.distanceTo(vb);
    }

    // Function to calculate facial landmarks positions
    function calculateFacialLandmarks(landmarks) {
      // Check if landmarks exist
      if (!landmarks || landmarks.length < 468) {
        console.warn('Invalid landmarks data');
        return null;
      }

      try {
        // Nose landmarks
        const noseTip = landmarks[1];
        const noseBridge = landmarks[168];
        const noseCenter = {
          x: (noseTip.x + noseBridge.x) / 2,
          y: (noseTip.y + noseBridge.y) / 2,
          z: (noseTip.z + noseBridge.z) / 2
        };

        // Eye landmarks
        const leftEye = landmarks[33];
        const rightEye = landmarks[263];
        const eyeCenter = {
          x: (leftEye.x + rightEye.x) / 2,
          y: (leftEye.y + rightEye.y) / 2,
          z: (leftEye.z + rightEye.z) / 2
        };

        // Eyebrow landmarks
        const leftEyebrow = landmarks[70];
        const rightEyebrow = landmarks[300];
        const eyebrowCenter = {
          x: (leftEyebrow.x + rightEyebrow.x) / 2,
          y: (leftEyebrow.y + rightEyebrow.y) / 2,
          z: (leftEyebrow.z + rightEyebrow.z) / 2
        };

        // Chin landmark
        const chin = landmarks[152];

        // Mouth landmarks
        const upperLip = landmarks[13];
        const lowerLip = landmarks[14];
        const mouthCenter = {
          x: (upperLip.x + lowerLip.x) / 2,
          y: (upperLip.y + lowerLip.y) / 2,
          z: (upperLip.z + lowerLip.z) / 2
        };

        return {
          nose: noseCenter,
          eye: eyeCenter,
          eyebrow: eyebrowCenter,
          chin: chin,
          mouth: mouthCenter,
          leftEye: leftEye,
          rightEye: rightEye,
          leftEyebrow: leftEyebrow,
          rightEyebrow: rightEyebrow
        };
      } catch (error) {
        console.error('Error calculating facial landmarks:', error);
        return null;
      }
    }

    // üé≠ FACE MASK GEOMETRY FOR DEPTH MASKING
    // T·∫°o geometry m·∫∑t n·∫° t·ª´ face landmarks ƒë·ªÉ l√†m depth mask
    function createFaceMaskGeometry(landmarks) {
      if (!landmarks || landmarks.length < 468) {
        console.warn('Invalid landmarks for face mask');
        return null;
      }

      try {
        // ƒê·ªãnh nghƒ©a c√°c ƒëi·ªÉm contour c·ªßa khu√¥n m·∫∑t ƒë·ªÉ t·∫°o m·∫∑t n·∫°
        const faceContourIndices = [
          // Face outline - vi·ªÅn khu√¥n m·∫∑t
          10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288,
          397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136,
          172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
        ];

        // T·∫°o array c√°c ƒë·ªânh t·ª´ landmarks
        const vertices = [];
        const indices = [];

        // Map landmarks th√†nh Three.js coordinates
        faceContourIndices.forEach((landmarkIndex, i) => {
          const landmark = landmarks[landmarkIndex];
          if (landmark) {
            // Convert coordinates
            const pos = mapToThreeJS(landmark.x, landmark.y, landmark.z || -2.5, true);
            vertices.push(pos.x, pos.y, pos.z);
          }
        });

        // T·∫°o triangulation ƒë∆°n gi·∫£n cho face mask
        // S·ª≠ d·ª•ng fan triangulation t·ª´ center point
        const centerIndex = Math.floor(faceContourIndices.length / 2);
        
        for (let i = 0; i < faceContourIndices.length - 1; i++) {
          if (i !== centerIndex && i + 1 !== centerIndex) {
            indices.push(centerIndex, i, i + 1);
          }
        }
        
        // Close the loop
        if (faceContourIndices.length > 2) {
          indices.push(centerIndex, faceContourIndices.length - 1, 0);
        }

        // T·∫°o BufferGeometry
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setIndex(indices);
        geometry.computeVertexNormals();

        return geometry;

      } catch (error) {
        console.error('Error creating face mask geometry:', error);
        return null;
      }
    }

    // Function to scale landmarks from center for face mask
    function scaleLandmarksFromCenter(landmarks, scaleFactor = 2.0) {
      // Find the center of the face (using nose tip as reference)
      const noseTip = landmarks[1]; // Nose tip landmark
      const faceCenter = {
        x: noseTip.x,
        y: noseTip.y,
        z: noseTip.z || 0
      };

      // Scale each landmark from the face center
      const scaledLandmarks = landmarks.map(landmark => {
        // Calculate offset from center
        const offsetX = landmark.x - faceCenter.x;
        const offsetY = landmark.y - faceCenter.y;
        const offsetZ = (landmark.z || 0) - faceCenter.z;

        // Apply scale factor to offset and add back to center
        return {
          x: faceCenter.x + offsetX * scaleFactor,
          y: faceCenter.y + offsetY * scaleFactor,
          z: faceCenter.z + offsetZ * scaleFactor,
          visibility: landmark.visibility
        };
      });

      return scaledLandmarks;
    }

    // Update face mask mesh v·ªõi geometry m·ªõi - SCALED 2X
    function updateFaceMask(landmarks) {
      // Scale landmarks g·∫•p ƒë√¥i cho face mask
      const scaledLandmarks = scaleLandmarksFromCenter(landmarks, 2.0);
      const newGeometry = createFaceMaskGeometry(scaledLandmarks);
      
      if (newGeometry) {
        // N·∫øu ƒë√£ c√≥ face mask mesh, update geometry
        if (faceMaskMesh) {
          faceMaskMesh.geometry.dispose(); // Clean up old geometry
          faceMaskMesh.geometry = newGeometry;
        } else {
          // T·∫°o mesh m·ªõi v·ªõi depth mask material
          faceMaskMesh = new THREE.Mesh(newGeometry, depthMaskMaterial);
          faceMaskMesh.renderOrder = -1; // Render tr∆∞·ªõc ƒë·ªÉ ghi depth buffer
          scene.add(faceMaskMesh);
        }
      }
    }

    // Function to map normalized screen coordinates to Three.js world coordinates using camera unprojection
    function mapToThreeJSWorld(xNorm, yNorm, camera, depth = -2.5) {
      // xNorm, yNorm: [0..1] ‚Üí screen space (MediaPipe)
      // Convert t·ª´ [0..1] v·ªÅ [-1..1] ƒë·ªÉ d√πng ray
      const x = (xNorm - 0.5) * 2;
      const y = -(yNorm - 0.5) * 2;

      // T·∫°o ray t·ª´ camera qua m√†n h√¨nh
      const vector = new THREE.Vector3(x, y, 0.5);
      vector.unproject(camera);

     // Ray ƒëi t·ª´ camera ƒë·∫øn vector
      const dir = vector.sub(camera.position).normalize();

      // T√≠nh ƒëi·ªÉm tr√™n ray t·∫°i z = depth
      const distance = (depth - camera.position.z) / dir.z;
      const pos = camera.position.clone().add(dir.multiplyScalar(distance));

      return pos;
  }

  // b·ªüi v·ªã d√πng clamped Math n√™n n√≥ b·ªã gi·ªõi h·∫°n v·ªã tr√≠ t·ª´ 0 ƒë·∫øn 1, ·ªü r√¨a th√¨ n√≥ l·ªõn h∆°n 1 n√™n ph·∫£i ch·ªânh l·∫°i
  function oldMapToThreeJS(x, y, z) {
      // Clamp coordinates to prevent extreme values at screen edges
      const clampedX = Math.max(0, Math.min(1, x));
      const clampedY = Math.max(0, Math.min(1, y));
      const clampedZ = Math.max(-1, Math.min(1, z));
      
      // Map to Three.js coordinate system
      const threeX = -(clampedX * 1280 - 640) / 1280 * 3;
      const threeY = -(clampedY * 720 - 360) / 720 * 3;
      const threeZ = -clampedZ * 1000 / 200;
      
      // Add small smoothing for edge positions to prevent jitter
      const edgeThreshold = 0.1; // 10% from edge
      let smoothedX = threeX;
      let smoothedY = threeY;
      
      if (clampedX < edgeThreshold || clampedX > (1 - edgeThreshold)) {
        // Apply slight smoothing at edges
        smoothedX = threeX * 0.95;
      }
      if (clampedY < edgeThreshold || clampedY > (1 - edgeThreshold)) {
        // Apply slight smoothing at edges
        smoothedY = threeY * 0.95;
      }
      
      return {
        x: smoothedX,
        y: smoothedY,
        z: threeZ
      };
    }

    // Function to map 2D coordinates to Three.js coordinates with edge handling
    function mapToThreeJS(x, y, z, mirror = true) {
  const aspect = 1280 / 720;
  const fov = 45;
  const depth = 5;

  const vFovInRad = (fov * Math.PI) / 180;
  const heightAtZ = 2 * Math.tan(vFovInRad / 2) * depth;
  const widthAtZ = heightAtZ * aspect;

  const ndcX = (x - 0.5) * 2;
  const ndcY = (y - 0.5) * 2;

  let threeX = ndcX * (widthAtZ / 2);
  let threeY = -ndcY * (heightAtZ / 2);
  let threeZ = -z * 5;

  // üëâ Mirror n·∫øu c·∫ßn (v√¨ b·∫°n ƒë√£ l·∫≠t canvas b·∫±ng scale(-1, 1))
  if (mirror) {
    threeX *= -1;
  }

  return { x: threeX, y: threeY, z: threeZ };
}
    // Function to apply smoothing to rotation
    function smoothRotation(target, current, factor) {
      return {
        x: current.x + (target.x - current.x) * factor,
        y: current.y + (target.y - current.y) * factor,
        z: current.z + (target.z - current.z) * factor
      };
    }

              // üé≠ HEAD REPLACEMENT STENCIL BUFFER RENDER FUNCTION
     function renderWithHeadReplacement() {
       if (!enableDepthMask) {
         // N·∫øu kh√¥ng b·∫≠t, render hatScene b√¨nh th∆∞·ªùng
         renderer.render(hatScene, camera);
        return;
      }

       // N·∫øu kh√¥ng b·∫≠t head replacement, d√πng logic c≈© (depth masking)
       if (!enableHeadReplacement) {
         // === DEPTH MASKING LOGIC (Old behavior) ===
         renderer.clear(true, true, true);
         const gl = renderer.context;
         
         renderer.state.buffers.stencil.setTest(true);
         renderer.state.buffers.stencil.setFunc(gl.ALWAYS, 1, 0xFF);
         renderer.state.buffers.stencil.setOp(gl.KEEP, gl.KEEP, gl.REPLACE);
         
         headOccluder.visible = true;
         headOccluder.material = showHeadOccluderDebug ? 
           new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.3 }) :
           stencilMat;
         
         renderer.render(headScene, camera);
         
         renderer.state.buffers.stencil.setFunc(gl.NOTEQUAL, 1, 0xFF);
         renderer.state.buffers.stencil.setOp(gl.KEEP, gl.KEEP, gl.KEEP);
         
         renderer.render(hatScene, camera);
         renderer.state.buffers.stencil.setTest(false);
         return;
       }

       // Clear all buffers
       renderer.clear(true, true, true); // color, depth, stencil

       const gl = renderer.context;
       
       // === PASS 1: Head Occluder - ghi stencil buffer (v√πng c·∫ßn thay th·∫ø) ===
       renderer.state.buffers.stencil.setTest(true);
       renderer.state.buffers.stencil.setFunc(gl.ALWAYS, 1, 0xFF);
       renderer.state.buffers.stencil.setOp(gl.KEEP, gl.KEEP, gl.REPLACE);
       
       // Head occluder ch·ªâ ghi stencil, kh√¥ng ghi m√†u
       headOccluder.visible = true;
       headOccluder.material = stencilMat; // Kh√¥ng ghi m√†u
       headOccluder.material.colorWrite = false;
       headOccluder.material.depthWrite = false;
       
       renderer.render(headScene, camera);

       // === PASS 2: Background/Video - render n∆°i stencil != 1 (b·ªè qua v√πng ƒë·∫ßu) ===
       renderer.state.buffers.stencil.setFunc(gl.NOTEQUAL, 1, 0xFF);
       renderer.state.buffers.stencil.setOp(gl.KEEP, gl.KEEP, gl.KEEP);
       
       // T·∫°o background plane t·ª´ video texture ƒë·ªÉ render ph·∫ßn kh√¥ng ph·∫£i ƒë·∫ßu
       if (!window.backgroundPlane) {
         const bgGeometry = new THREE.PlaneGeometry(20, 20);
         
         // T·∫°o video texture t·ª´ camera feed
         let videoTexture = null;
         if (videoElement) {
           videoTexture = new THREE.VideoTexture(videoElement);
           videoTexture.minFilter = THREE.LinearFilter;
           videoTexture.magFilter = THREE.LinearFilter;
         }
         
         const bgMaterial = new THREE.MeshBasicMaterial({ 
           map: videoTexture || null,
           color: videoTexture ? 0xffffff : 0x888888, // Tr·∫Øng n·∫øu c√≥ texture, x√°m n·∫øu kh√¥ng
           transparent: false,
           side: THREE.FrontSide
         });
         
         window.backgroundPlane = new THREE.Mesh(bgGeometry, bgMaterial);
         window.backgroundPlane.position.z = -10; // ƒê·∫∑t xa camera
         scene.add(window.backgroundPlane);
         
         console.log('üé¨ Background plane created with video texture:', !!videoTexture);
       }
       
       // Update video texture n·∫øu c·∫ßn
       if (window.backgroundPlane.material.map && videoElement) {
         window.backgroundPlane.material.map.needsUpdate = true;
       }
       
       // Render background (s·∫Ω b·ªè qua v√πng stencil = 1)
      renderer.render(scene, camera);
      
       // === PASS 3: Hat - ch·ªâ render ·ªü v√πng stencil = 1 (thay th·∫ø ƒë·∫ßu) ===
       renderer.state.buffers.stencil.setFunc(gl.EQUAL, 1, 0xFF);
       renderer.state.buffers.stencil.setOp(gl.KEEP, gl.KEEP, gl.KEEP);
       
       // Render m≈© ch·ªâ trong v√πng ƒë·∫ßu
       renderer.render(hatScene, camera);
       
       // === DEBUG: Hi·ªÉn th·ªã head occluder n·∫øu b·∫≠t debug ===
       if (showHeadOccluderDebug) {
         renderer.state.buffers.stencil.setTest(false);
         headOccluder.material = new THREE.MeshBasicMaterial({ 
           color: 0x0000ff, 
           transparent: true, 
           opacity: 0.2,
           wireframe: true
         });
         headOccluder.material.colorWrite = true;
         renderer.render(headScene, camera);
       }
       
       // Disable stencil test
       renderer.state.buffers.stencil.setTest(false);
    }

    // MediaPipe FaceMesh Configuration
    const faceMesh = new FaceMesh({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
      }
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.3, // Gi·∫£m ƒë·ªÉ tracking t·ªët h∆°n ·ªü r√¨a m√†n h√¨nh
      minTrackingConfidence: 0.3   // Gi·∫£m ƒë·ªÉ tracking t·ªët h∆°n ·ªü r√¨a m√†n h√¨nh
    });



    
    // H√†m Main c·ªßa code
    // Process FaceMesh results
    faceMesh.onResults((results) => {
      // Save canvas context BEFORE try block to ensure it's always saved
      canvasCtx.save();
      
      try {
        // Clear the 2D canvas
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        // L·∫≠t ngang canvas ƒë·ªÉ s·ª≠a camera mirror
        canvasCtx.translate(canvasElement.width, 0);
        canvasCtx.scale(-1, 1);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
          trackingLostFrames = 0; // Reset tracking lost counter
          
        for (const landmarks of results.multiFaceLandmarks) {
          console.log('üéØ DEBUG: showMesh =', showMesh, 'landmarks found'); // DEBUG
          
                     // Draw face mesh components if enabled
           if (showMesh) {
             console.log('üñºÔ∏è Drawing face mesh'); // DEBUG
             // Draw FACEMESH_TESSELATION (main mesh)
             if (showMeshTesselation) {
               drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, 
                 { color: '#50DCF0', lineWidth: 1, circleRadius: 1 });
             }
             
             // Draw FACEMESH_CONTOURS (face contours)
             if (showMeshContours) {
               drawConnectors(canvasCtx, landmarks, FACEMESH_CONTOURS, 
                 { color: '#0000FF', lineWidth: 2, circleRadius: 2 });
             }
             
             // Draw FACEMESH_IRISES (eye irises)
             if (showMeshIrises) {
               drawConnectors(canvasCtx, landmarks, FACEMESH_IRISES, 
                 { color: '#00FFFF', lineWidth: 2, circleRadius: 2 });
             }
           }

          console.log('üéØ TRACKING: Starting head fit calculation'); // DEBUG
          
          // Calculate head fit and position - tracking theo forehead
          const headFit = calculateHeadFit(landmarks);
          
          // üé≠ UPDATE FACE MASK for depth masking
          updateFaceMask(landmarks);
          
          // No need for initial head detection anymore - using dynamic scaling per frame
          
          // Map forehead position to Three.js coordinate system - model s·∫Ω ƒë·∫∑t ch√≠nh x√°c theo v·ªã tr√≠ tr√°n
          const threeX = -(headFit.center.x * 1280 - 640) / 1280 * 3;
          const threeY = -(headFit.center.y * 720 - 360) / 720 * 3;
          const threeZ = -headFit.center.z * 1000 / 200;

          // Calculate head rotation
          const headRotation = calculateHeadRotation(landmarks);
          
          console.log('üéØ TRACKING: Head rotation calculated', headRotation); // DEBUG

          // Apply smoothing to rotation
          targetRotation = headRotation;
          currentRotation = smoothRotation(targetRotation, currentRotation, smoothingFactor);

          // Calculate facial landmarks
          const facialLandmarks = calculateFacialLandmarks(landmarks);

          // Position and rotate the hat model - ƒë·∫∑t ch√≠nh x√°c t·∫°i forehead
          if (hatModel && facialLandmarks) {
            // Calculate nose bridge direction for reference line
            const noseDirection = calculateNoseBridgeDirection(landmarks);
            
            // Update reference line position and rotation
            referenceLine.position.set(threeX, threeY, threeZ);
            referenceLine.rotation.z = Math.atan2(noseDirection.y, noseDirection.x);
            referenceLine.visible = false; // ·∫®n ƒë∆∞·ªùng ƒë·ªè
            
            // C·∫≠p nh·∫≠t ƒë∆∞·ªùng th·∫≥ng t·ª´ c·∫±m ƒë·∫øn gi·ªØa l√¥ng m√†y song song v·ªõi tr·ª•c Oy
            const chinPos = mapToThreeJS(facialLandmarks.chin.x, facialLandmarks.chin.y, facialLandmarks.chin.z);
            const eyebrowCenterPos = mapToThreeJS(facialLandmarks.eyebrow.x, facialLandmarks.eyebrow.y, facialLandmarks.eyebrow.z);
            
            // ƒê·∫∑t v·ªã tr√≠ c·ªßa ƒë∆∞·ªùng th·∫≥ng t·∫°i ƒëi·ªÉm gi·ªØa c·ªßa c·∫±m v√† l√¥ng m√†y
            const middleX = (chinPos.x + eyebrowCenterPos.x) / 2;
            const middleY = (chinPos.y + eyebrowCenterPos.y) / 2;
            const middleZ = (chinPos.z + eyebrowCenterPos.z) / 2;
            
            chinToEyebrowLine.position.set(middleX, middleY, middleZ);
            
            // √Åp d·ª•ng rotation c·ªßa ƒë·∫ßu ƒë·ªÉ ƒë∆∞·ªùng th·∫≥ng tracking theo m·∫∑t khi nghi√™ng ƒë·∫ßu
            chinToEyebrowLine.rotation.x = currentRotation.x;
            chinToEyebrowLine.rotation.y = currentRotation.y;
            chinToEyebrowLine.rotation.z = currentRotation.z;
            
            chinToEyebrowLine.visible = false;
            
            // C·∫≠p nh·∫≠t ƒë∆∞·ªùng l√¥ng m√†y
            const eyebrowPos = mapToThreeJS(facialLandmarks.eyebrow.x, facialLandmarks.eyebrow.y, facialLandmarks.eyebrow.z);
            eyebrowLine.position.set(eyebrowPos.x, eyebrowPos.y, eyebrowPos.z);
            eyebrowLine.rotation.z = Math.atan2(noseDirection.y, noseDirection.x);
            eyebrowLine.visible = false;
            
            // C·∫≠p nh·∫≠t ƒë∆∞·ªùng m·∫Øt
            const eyePos = mapToThreeJS(facialLandmarks.eye.x, facialLandmarks.eye.y, facialLandmarks.eye.z);
            eyeLine.position.set(eyePos.x, eyePos.y, eyePos.z);
            eyeLine.rotation.z = Math.atan2(noseDirection.y, noseDirection.x);
            eyeLine.visible = false;
            
            // C·∫≠p nh·∫≠t ƒë∆∞·ªùng mi·ªáng
            const mouthPos = mapToThreeJS(facialLandmarks.mouth.x, facialLandmarks.mouth.y, facialLandmarks.mouth.z);
            mouthLine.position.set(mouthPos.x, mouthPos.y, mouthPos.z);
            mouthLine.rotation.z = Math.atan2(noseDirection.y, noseDirection.x);
            mouthLine.visible = false;
            
            // Hide all outline meshes (t·∫Øt ho√†n to√†n)
            noseOutline.visible = false;
            leftEyeOutline.visible = false;
            rightEyeOutline.visible = false;
            leftEyebrowOutline.visible = false;
            rightEyebrowOutline.visible = false;
            mouthOutline.visible = false;
             
                         // Check if hat model exists
            if (hatModel && headFit) {
              console.log('üé© MODEL: Updating hat position and rotation'); // DEBUG
              
              // Calculate hybrid position: X,Z from head center, Y from forehead
              const trueHeadCenter = calculateTrueHeadCenter(landmarks);
              let hatPos;
              
              if (trueHeadCenter) {
                // Use head center for X and Z (stable rotation pivot)
                hatPos = mapToThreeJS(trueHeadCenter.x, trueHeadCenter.y, trueHeadCenter.z + 0.08, true);
                
                // Override Y position with forehead position for proper hat placement
                const foreheadLandmark = landmarks[10]; // Forehead center
                if (foreheadLandmark) {
                  const foreheadPos = mapToThreeJS(foreheadLandmark.x, foreheadLandmark.y, foreheadLandmark.z, true);
                  hatPos.y = foreheadPos.y + hatYOffset; // Use configurable hat Y offset
                  console.log('üé© Using hybrid position: X,Z from head center, Y from forehead');
                } else {
                  hatPos.y -= 0.05; // Fallback offset
                }
              } else {
                // Fallback to old method
                hatPos = mapToThreeJS(headFit.center.x, headFit.center.y, headFit.center.z + 0.08, true);
                hatPos.y -= 0.15; // Original offset for old method
                console.warn('‚ö†Ô∏è Fallback to old positioning method');
              }

              // Debug: Check if position is at screen edges
              const isAtEdge = headFit.center.x < edgeTrackingSensitivity || headFit.center.x > (1 - edgeTrackingSensitivity) || 
                              headFit.center.y < edgeTrackingSensitivity || headFit.center.y > (1 - edgeTrackingSensitivity);
              
              if (isAtEdge) {
                console.log('‚ö†Ô∏è Tracking ·ªü r√¨a m√†n h√¨nh:', {
                  x: headFit.center.x.toFixed(3),
                  y: headFit.center.y.toFixed(3),
                  z: headFit.center.z.toFixed(3)
                });
                
                // Thay ƒë·ªïi m√†u model khi ·ªü r√¨a ƒë·ªÉ debug
                if (hatModel.children.length > 0) {
                  hatModel.children.forEach(child => {
                    if (child.material) {
                      child.material.color.setHex(0xff0000); // ƒê·ªè khi ·ªü r√¨a
                    }
                  });
                }
              } else {
                // Kh√¥i ph·ª•c m√†u b√¨nh th∆∞·ªùng
                if (hatModel.children.length > 0) {
                  hatModel.children.forEach(child => {
                    if (child.material) {
                      child.material.color.setHex(0xffffff); // Tr·∫Øng khi ·ªü gi·ªØa
                    }
                  });
                }
              }

              // L∆∞u v·ªã tr√≠ hi·ªán t·∫°i l√†m last known position
              lastKnownPosition = { x: hatPos.x, y: hatPos.y, z: hatPos.z };
              
              // L√†m m∆∞·ª£t v·ªã tr√≠ v·ªõi smoothing kh√°c nhau cho edge v√† center
              const edgeSmoothingFactor = isAtEdge ? smoothingFactor * 0.7 : smoothingFactor; // Gi·∫£m smoothing ·ªü edge
              hatModel.position.lerp(hatPos, edgeSmoothingFactor);

              // Apply dynamic scaling per frame
               // N·∫øu ƒëang ·ªü mode head replacement, scale m≈© l·ªõn h∆°n ƒë·ªÉ che to√†n b·ªô ƒë·∫ßu
               const scaleBoostForReplacement = enableHeadReplacement ? 1.5 : 1.0;
              applyDynamicScalePerFrame(hatModel, headFit, 'hat');

               // Apply additional scale boost for head replacement
               if (enableHeadReplacement) {
                 hatModel.scale.multiplyScalar(scaleBoostForReplacement);
               }

  // G√°n xoay b·∫±ng quaternion - rotation v·∫´n d·ª±a tr√™n head center
  const rotMatrix = calculateHeadRotationMatrix(landmarks);
  const targetQuat = new THREE.Quaternion().setFromRotationMatrix(rotMatrix);
  hatModel.quaternion.slerp(targetQuat, smoothingFactor);

  // Note: Hat rotates around head center but positioned at forehead level

     // üîµ HEAD OCCLUDER - Professional Implementation
     if (headOccluder && landmarks) {
       // === helpers ===
       const v3 = (lm) => new THREE.Vector3(
         mapToThreeJS(lm.x, lm.y, lm.z, true).x,
         mapToThreeJS(lm.x, lm.y, lm.z, true).y,
         mapToThreeJS(lm.x, lm.y, lm.z, true).z
       );
       const distW = (a,b)=> v3(a).distanceTo(v3(b));

       // === landmarks ch√≠nh ===
       const L = landmarks;
       const L_earL = L[234], L_earR = L[454];
       const L_fore  = L[10],  L_chin = L[152];
       const L_nose  = L[8];   // s·ªëng m≈©i gi√∫p ki·ªÉm tra h∆∞·ªõng Z

       if (L_earL && L_earR && L_fore && L_chin) {
         // Tr·ª•c c∆° s·ªü: X = tai‚Üítai, Y = l√™n (tr√°n‚Üíc·∫±m), Z = h∆∞·ªõng m·∫∑t (ph·∫£i h∆∞·ªõng ra tr∆∞·ªõc)
         const xAxis = v3(L_earR).clone().sub(v3(L_earL)).normalize();
         const yAxis = v3(L_fore).clone().sub(v3(L_chin)).normalize().negate(); // up
         let zAxis   = new THREE.Vector3().crossVectors(xAxis, yAxis).normalize();

         // ƒê·∫£m b·∫£o zAxis th·∫≠t s·ª± h∆∞·ªõng "ra tr∆∞·ªõc m·∫∑t" (v·ªÅ ph√≠a m≈©i)
         if (L_nose) {
           const forward = v3(L_nose).clone().sub(v3(L_fore)).normalize(); // tr√°n -> m≈©i
           if (zAxis.dot(forward) < 0) zAxis.multiplyScalar(-1);
         }
         // tr·ª±c chu·∫©n l·∫°i ƒë·ªÉ tr√°nh xi√™n
         yAxis.crossVectors(zAxis, xAxis).normalize();

         // T√¢m g∆∞∆°ng m·∫∑t s∆° b·ªô
         const centerFace = new THREE.Vector3()
           .add(v3(L_earL)).add(v3(L_earR)).add(v3(L_fore)).add(v3(L_chin)).multiplyScalar(0.25);

         // K√≠ch th∆∞·ªõc th·ª±c t·∫ø (ƒë∆°n v·ªã world c·ªßa b·∫°n)
         const headW = distW(L_earL, L_earR);   // ngang tai‚Äìtai
         const headH = distW(L_fore,  L_chin);  // cao tr√°n‚Äìc·∫±m
         // ∆Ø·ªõc l∆∞·ª£ng ƒë·ªô s√¢u h·ªôp s·ªç (g√°y) ~ 0.95‚Äì1.10 √ó headW (tu·ª≥ camera & face size)
         const headD = headW * 1.05;            // tƒÉng n·∫øu c√≤n h·ªü g√°y

         // T√¢m h·ªôp s·ªç: l√πi v√†o **n·ª≠a** ƒë·ªô s√¢u d·ªçc theo -Z (v√¨ Z ƒëang h∆∞·ªõng ra tr∆∞·ªõc)
         const headCenter = centerFace.clone().add(zAxis.clone().multiplyScalar(-0.5 * headD));
         
                  // G√°n pose CHO HEAD PROXY (ƒë·ª´ng g√°n theo m≈©)
         headProxy.position.z += 0.08;
         headProxy.position.lerp(headCenter, 0.35);   // l√†m m∆∞·ª£t
         const basis = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);
         const qTarget = new THREE.Quaternion().setFromRotationMatrix(basis);
         headProxy.quaternion.slerp(qTarget, 0.35);

                   // üéØ SCALE HEAD PROXY C·ªê ƒê·ªäNH 1.2 L·∫¶N K√çCH TH∆Ø·ªöC M·∫∂T
          // T√≠nh scale factor c·ªë ƒë·ªãnh 1.2 l·∫ßn k√≠ch th∆∞·ªõc m·∫∑t
          const faceSize = (3.14 * (3*(headH + headW)/2 - Math.sqrt((3*headH+headW)*(headH+3*headD)/4))); // L·∫•y k√≠ch th∆∞·ªõc nh·ªè nh·∫•t c·ªßa m·∫∑t
          const fixedScaleFactor = faceSize * 1.1; // Lu√¥n scale 1.2 l·∫ßn
          
          // √Åp d·ª•ng scale c·ªë ƒë·ªãnh cho headProxy
          const targetScale = new THREE.Vector3(fixedScaleFactor, fixedScaleFactor, fixedScaleFactor);
          headProxy.scale.lerp(targetScale, 0.35); // Smoothing nh·∫π

         // Scale ellipsoid (sphere g·ªëc radius = 0.5 ‚áí scale ‚âà ƒë∆∞·ªùng k√≠nh mong mu·ªën)
         const kW = 0.98 * headOccluderSizeMultiplier, 
               kH = 1.08 * headOccluderSizeMultiplier, 
               kD = 1.14 * headOccluderSizeMultiplier; // tƒÉng kD n·∫øu c√≤n h·ªü g√°y
         headOccluder.scale.set(headW * kW, headH * kH, headD * kD);

         // V·∫≠t li·ªáu occluder: ch·ªâ ghi depth ‚Äì ƒë·ª´ng ghi m√†u, double side
         headOccluder.material.colorWrite = false;
         headOccluder.material.depthWrite = true;
         headOccluder.material.depthTest  = true;
         headOccluder.material.side       = THREE.DoubleSide;
         headOccluder.renderOrder = -2; // v·∫Ω s·ªõm
         
                   // Debug log
          if (Math.random() < 0.02) { // Log 2% frames ƒë·ªÉ kh√¥ng spam
            console.log('üîµ Professional Head Occluder:', {
              center: headCenter,
              scale: headOccluder.scale,
              headProxyScale: headProxy.scale,
              faceSize: faceSize.toFixed(3),
              fixedScaleFactor: fixedScaleFactor.toFixed(3),
              dimensions: { width: headW.toFixed(3), height: headH.toFixed(3), depth: headD.toFixed(3) },
              axes: { x: xAxis, y: yAxis, z: zAxis }
            });
          }
       }
     }

  // C·∫≠p nh·∫≠t modelAxes - hi·ªÉn th·ªã t·∫°i pivot point (head center)
  if (landmarks) {
    const trueHeadCenter = calculateTrueHeadCenter(landmarks);
    if (trueHeadCenter) {
      const headCenterPos = mapToThreeJS(trueHeadCenter.x, trueHeadCenter.y, trueHeadCenter.z, true);
      modelAxes.position.copy(headCenterPos);
    } else {
      modelAxes.position.copy(hatModel.position);
    }
  } else {
    modelAxes.position.copy(hatModel.position);
  }
  modelAxes.quaternion.copy(hatModel.quaternion);
  modelAxes.scale.set(1, 1, 1); // Keep axes at unit scale
  modelAxes.visible = showAxes;

  // Glasses tracking - track with eyes or head center
  if (glassesModel && facialLandmarks && facialLandmarks.eye) {
    let glassesPos;
    
    // Option to use head center for glasses too (more stable rotation)
    const trueHeadCenter = calculateTrueHeadCenter(landmarks);
    if (trueHeadCenter && enableHeadCenterForGlasses) {
      glassesPos = mapToThreeJS(trueHeadCenter.x, trueHeadCenter.y, trueHeadCenter.z-0.15, true);
      glassesPos.y += 0.07; // Offset up to eye level from head center
    } else {
      // Default: track with eyes
      glassesPos = mapToThreeJS(facialLandmarks.eye.x, facialLandmarks.eye.y, facialLandmarks.eye.z -0.15);
    }
    
    glassesPos.y += glassesYOffset; // Use configurable Y offset
    
    // Apply smoothing to glasses position
    glassesModel.position.lerp(glassesPos, smoothingFactor);

    // Apply dynamic scaling per frame for glasses
    applyDynamicScalePerFrame(glassesModel, headFit, 'glasses');

    // Apply head rotation to glasses
    glassesModel.quaternion.slerp(targetQuat, smoothingFactor);
  }
}
          }
        }
      }
      } catch (error) {
        console.error('Error in faceMesh processing:', error);
      } finally {
        // ALWAYS restore canvas context in finally block to prevent mirror effect accumulation
        canvasCtx.restore();
        
                 // üé≠ HEAD REPLACEMENT STENCIL BUFFER RENDERING
         renderWithHeadReplacement();
      }
    });

    // Load settings on startup
    loadSettings();
    
    // Initialize UI values
    document.getElementById('smoothing').value = smoothingFactor;
    document.getElementById('smoothing-value').textContent = smoothingFactor.toFixed(2);
    document.getElementById('edge-tracking').value = edgeTrackingSensitivity;
    document.getElementById('edge-tracking-value').textContent = edgeTrackingSensitivity.toFixed(2);
    
    // Initialize glasses UI values
    document.getElementById('glasses-y-offset').value = glassesYOffset;
    document.getElementById('glasses-y-offset-value').textContent = glassesYOffset.toFixed(2);
    
    // Initialize hat UI values
    document.getElementById('hat-y-offset').value = hatYOffset;
    document.getElementById('hat-y-offset-value').textContent = hatYOffset.toFixed(2);
    
    // Initialize model scale boost UI
    document.getElementById('model-scale-boost').value = modelScaleBoost;
    document.getElementById('model-scale-boost-value').textContent = modelScaleBoost.toFixed(1);
    
    // Initialize head occluder size UI
    document.getElementById('head-occluder-size').value = headOccluderSizeMultiplier;
    document.getElementById('head-occluder-size-value').textContent = headOccluderSizeMultiplier.toFixed(1);
    
    // Initialize head proxy scale sensitivity UI
    document.getElementById('head-proxy-scale-sensitivity').value = headProxyScaleSensitivity;
    document.getElementById('head-proxy-scale-sensitivity-value').textContent = headProxyScaleSensitivity.toFixed(1);

    // Start the camera
    const cameraFeed = new Camera(videoElement, {
      onFrame: async () => {
        try {
          await faceMesh.send({ image: videoElement });
        } catch (error) {
          console.error('Error sending frame to faceMesh:', error);
        }
      },
      width: 1280,
      height: 720
    });
    
    // Start camera with error handling
    cameraFeed.start().catch(error => {
      console.error('Error starting camera:', error);
      alert('Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông camera. Vui l√≤ng ki·ªÉm tra quy·ªÅn truy c·∫≠p camera.');
    });

    // Settings panel toggle
    // üõ°Ô∏è SAFE SETTINGS CONTROLS
    safeAddEventListener('settings-toggle', 'click', () => {
      const panel = document.getElementById('settings-panel');
      if (panel) {
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
      }
    });

    safeAddEventListener('save-settings', 'click', () => {
      saveSettings();
      alert('‚úÖ Settings ƒë√£ ƒë∆∞·ª£c l∆∞u!');
    });

    safeAddEventListener('reset-settings', 'click', () => {
      if (confirm('‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc mu·ªën reset v·ªÅ settings m·∫∑c ƒë·ªãnh?')) {
        resetSettings();
        alert('üîÑ Settings ƒë√£ ƒë∆∞·ª£c reset!');
      }
    });

    // Auto-save settings when values change (with debounce)
    let saveTimeout;
    function autoSaveSettings() {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        saveSettings();
      }, 1000); // Save after 1 second of no changes
    }






    // üõ°Ô∏è SAFE SMOOTHING CONTROL
    safeAddEventListener('smoothing', 'input', (e) => {
      smoothingFactor = parseFloat(e.target.value);
      const smoothingValue = document.getElementById('smoothing-value');
      if (smoothingValue) {
        smoothingValue.textContent = smoothingFactor.toFixed(2);
      }
      autoSaveSettings();
    });





    // üõ°Ô∏è SAFE MESH CONTROLS
    safeAddEventListener('show-mesh', 'change', (e) => {
      showMesh = e.target.checked;
      autoSaveSettings();
    });

    safeAddEventListener('show-mesh-tesselation', 'change', (e) => {
      showMeshTesselation = e.target.checked;
      autoSaveSettings();
    });

    safeAddEventListener('show-mesh-contours', 'change', (e) => {
      showMeshContours = e.target.checked;
      autoSaveSettings();
    });

    safeAddEventListener('show-mesh-irises', 'change', (e) => {
      showMeshIrises = e.target.checked;
      autoSaveSettings();
    });

    safeAddEventListener('show-axes', 'change', (e) => {
      showAxes = e.target.checked;
      autoSaveSettings();
    });

    // üõ°Ô∏è SAFE DEPTH MASKING CONTROLS  
    safeAddEventListener('enable-depth-mask', 'change', (e) => {
      enableDepthMask = e.target.checked;
      autoSaveSettings();
    });

     safeAddEventListener('enable-head-replacement', 'change', (e) => {
       enableHeadReplacement = e.target.checked;
       console.log('üé≠ Head Replacement:', enableHeadReplacement ? 'B·∫¨T' : 'T·∫ÆT');
      autoSaveSettings();
    });

    safeAddEventListener('show-face-mask', 'change', (e) => {
      showFaceMaskDebug = e.target.checked;
      autoSaveSettings();
    });

    safeAddEventListener('show-head-occluder', 'change', (e) => {
      showHeadOccluderDebug = e.target.checked;
      autoSaveSettings();
    });

    safeAddEventListener('head-occluder-size', 'input', (e) => {
      headOccluderSizeMultiplier = parseFloat(e.target.value);
      const sizeValue = document.getElementById('head-occluder-size-value');
      if (sizeValue) {
        sizeValue.textContent = headOccluderSizeMultiplier.toFixed(1);
      }
      autoSaveSettings();
    });

    safeAddEventListener('head-proxy-scale-sensitivity', 'input', (e) => {
      headProxyScaleSensitivity = parseFloat(e.target.value);
      const sensitivityValue = document.getElementById('head-proxy-scale-sensitivity-value');
      if (sensitivityValue) {
        sensitivityValue.textContent = headProxyScaleSensitivity.toFixed(1);
      }
      autoSaveSettings();
    });

    // üõ°Ô∏è SAFE REMAINING CONTROLS
    safeAddEventListener('edge-tracking', 'input', (e) => {
      edgeTrackingSensitivity = parseFloat(e.target.value);
      const edgeTrackingValue = document.getElementById('edge-tracking-value');
      if (edgeTrackingValue) {
        edgeTrackingValue.textContent = edgeTrackingSensitivity.toFixed(2);
      }
      autoSaveSettings();
    });

    // Glasses controls
    safeAddEventListener('glasses-y-offset', 'input', (e) => {
      glassesYOffset = parseFloat(e.target.value);
      const glassesYOffsetValue = document.getElementById('glasses-y-offset-value');
      if (glassesYOffsetValue) {
        glassesYOffsetValue.textContent = glassesYOffset.toFixed(2);
      }
      autoSaveSettings();
    });

    // Hat Y Offset controls
    safeAddEventListener('hat-y-offset', 'input', (e) => {
      hatYOffset = parseFloat(e.target.value);
      const hatYOffsetValue = document.getElementById('hat-y-offset-value');
      if (hatYOffsetValue) {
        hatYOffsetValue.textContent = hatYOffset.toFixed(2);
      }
      autoSaveSettings();
    });
       
    // üéâ Setup completed
    console.log('‚úÖ Setup ho√†n t·∫•t!');
    // Remove loading indicator
    const loadingEl = document.getElementById('loading');
    if (loadingEl) loadingEl.remove();
    
    } // End of initApp function
    
 </script>
</body>
</html>